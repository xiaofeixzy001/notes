[TOC]

**RAID** 

raid的意思是廉价磁盘冗余阵列（Redundant Array of Inexpensive Disks），但现在它被称为独立磁盘冗余阵列（Redundant Array of 

Independent Drives）。早先一个容量很小的磁盘都是非常昂贵的，但是现在我们可以很便宜的买到一个更大的磁盘。Raid 是一系列放在一起，成为一个逻

辑卷的磁盘集合。

RAID 包含一组或者一个集合甚至一个阵列。使用一组磁盘结合驱动器组成 RAID 阵列或 RAID 集。将至少两个磁盘连接到一个 RAID 控制器，而成为一个逻

辑卷，也可以将多个驱动器放在一个组中。一组磁盘只能使用一个 RAID 级别。使用 RAID 可以提高服务器的性能。不同 RAID 的级别，性能会有所不同。它

通过容错和高可用性来保存我们的数据。

**软件 RAID 和硬件 RAID**

软件 RAID 的性能较低，因为其使用主机的资源。 需要加载 RAID 软件以从软件 RAID 卷中读取数据。在加载 RAID 软件前，操作系统需要引导起来才能加

载 RAID 软件。在软件 RAID 中无需物理硬件。零成本投资。

硬件 RAID 的性能较高。他们采用 PCI Express 卡物理地提供有专用的 RAID 控制器。它不会使用主机资源。他们有 NVRAM 用于缓存的读取和写入。缓存

用于 RAID 重建时，即使出现电源故障，它会使用后备的电池电源保持缓存。对于大规模使用是非常昂贵的投资。

**重要的 RAID 概念**

**校验**方式用在 RAID 重建中从校验所保存的信息中重新生成丢失的内容。 RAID 5，RAID 6 基于校验。

**条带化**是将切片数据随机存储到多个磁盘。它不会在单个磁盘中保存完整的数据。如果我们使用2个磁盘，则每个磁盘存储我们的一半数据。

**镜像**被用于 RAID 1 和 RAID 10。镜像会自动备份数据。在 RAID 1 中，它会保存相同的内容到其他盘上。

**热备份**只是我们的服务器上的一个备用驱动器，它可以自动更换发生故障的驱动器。在我们的阵列中，如果任何一个驱动器损坏，热备份驱动器会自动用于重建 

RAID。

**块**是 RAID 控制器每次读写数据时的最小单位，最小 4KB。通过定义块大小，我们可以增加 I/O 性能。

RAID有不同的级别。在这里，我们仅列出在真实环境下的使用最多的 RAID 级别。

**RAID 0** = 条带化

![img](Raid%E5%9F%BA%E7%A1%80.assets/6e8f30de-9ec8-4e54-9697-9507f92602e2.png)

条带化有很好的性能。在 RAID 0（条带化）中数据将使用切片的方式被写入到磁盘。一半的内容放在一个磁盘上，另一半内容将被写入到另一个磁盘。

假设我们有2个磁盘驱动器，例如，如果我们将数据“TECMINT”写到逻辑卷中，“T”将被保存在第一盘中，“E”将保存在第二盘，'C'将被保存在第一盘，“M”将保

存在第二盘，它会一直继续此循环过程。（LCTT 译注：实际上不可能按字节切片，是按数据块切片的。）

在这种情况下，如果驱动器中的任何一个发生故障，我们就会丢失数据，因为一个盘中只有一半的数据，不能用于重建 RAID。不过，当比较写入速度和性能时，

RAID 0 是非常好的。创建 RAID 0（条带化）至少需要2个磁盘。如果你的数据是非常宝贵的，那么不要使用此 RAID 级别。

特点：性能+，读写+，冗余 -

**RAID 1 = 镜像**

![img](Raid%E5%9F%BA%E7%A1%80.assets/07859e5c-13f7-4280-ac49-4127aa07ffcb.png)

镜像也有不错的性能。镜像可以对我们的数据做一份相同的副本。假设我们有两个2TB的硬盘驱动器，我们总共有4TB，但在镜像中，但是放在 RAID 控制器后面

的驱动器形成了一个逻辑驱动器，我们只能看到这个逻辑驱动器有2TB。

当我们保存数据时，它将同时写入这两个2TB驱动器中。创建 RAID 1（镜像化）最少需要两个驱动器。如果发生磁盘故障，我们可以通过更换一个新的磁盘恢

复 RAID 。如果在 RAID 1 中任何一个磁盘发生故障，我们可以从另一个磁盘中获取相同的数据，因为另外的磁盘中也有相同的数据。所以是零数据丢失。

特点：性能+，读+，冗余+，写-

良好的性能，总容量丢失一半可用空间，完全容错，重建会更快，写性能变慢，读性能变好，能用于操作系统和小规模的数据库；

**RAID 5 = 单磁盘分布式奇偶校验**

![img](Raid%E5%9F%BA%E7%A1%80.assets/e2424a57-1a94-48e6-882e-97a63a9bfc58.png)

RAID 5 多用于企业级。 RAID 5 的以分布式奇偶校验的方式工作。奇偶校验信息将被用于重建数据。它从剩下的正常驱动器上的信息来重建。在驱动器发生故

障时，这可以保护我们的数据。

假设我们有4个驱动器，如果一个驱动器发生故障而后我们更换发生故障的驱动器后，我们可以从奇偶校验中重建数据到更换的驱动器上。奇偶校验信息存储在所

有的4个驱动器上，如果我们有4个 1TB 的驱动器。奇偶校验信息将被存储在每个驱动器的256G中，而其它768GB是用户自己使用的。单个驱动器故障后，RAID 5 依旧正常工作，如果驱动器损坏个数超过1个会导致数据的丢失。

特点：性能+，读写+，冗余+

性能卓越，读速度将非常好，写速度处于平均水准，如果我们不使用硬件 RAID 控制器，写速度缓慢，从所有驱动器的奇偶校验信息中重建，完全容错，1个磁盘

空间将用于奇偶校验，可以被用在文件服务器，Web服务器，非常重要的备份中。

**RAID 6 = 双磁盘分布式奇偶校验**

![img](Raid%E5%9F%BA%E7%A1%80.assets/264e0df7-7372-4392-9496-c70d45e6b12a.png)

RAID 6 和 RAID 5 相似但它有两个分布式奇偶校验。大多用在大数量的阵列中。我们最少需要4个驱动器，即使有2个驱动器发生故障，我们依然可以更换新的

驱动器后重建数据。它比 RAID 5 慢，因为它将数据同时写到4个驱动器上。当我们使用硬件 RAID 控制器时速度就处于平均水准。如果我们有6个的1TB驱动

器，4个驱动器将用于数据保存，2个驱动器将用于校验。

特点：性能不佳，读的性能很好，如果我们不使用硬件 RAID 控制器写的性能会很差，从两个奇偶校验驱动器上重建，完全容错，2个磁盘空间将用于奇偶校验，

可用于大型阵列，用于备份和视频流中，用于大规模。

**RAID 10 = 镜像 + 条带。（嵌套RAID）**

![img](Raid%E5%9F%BA%E7%A1%80.assets/31bb1ebc-3156-4029-96b6-c73841ed99e9.jpg)

![img](Raid%E5%9F%BA%E7%A1%80.assets/a34863d9-11f0-4044-b541-653a52b624fa.png)

RAID 10 可以被称为1 + 0或0 +1。它将做镜像+条带两个工作。在 RAID 10 中首先做镜像然后做条带。在 RAID 01 上首先做条带，然后做镜像。RAID 

10 比 01 好；

假设，我们有4个驱动器。当我逻辑卷上写数据时，它会使用镜像和条带的方式将数据保存到4个驱动器上。

如果我在 RAID 10 上写入数据“TECMINT”，数据将使用如下方式保存。首先将“T”同时写入两个磁盘，“E”也将同时写入另外两个磁盘，所有数据都写入两块

磁盘。这样可以将每个数据复制到另外的磁盘。

同时它将使用 RAID 0 方式写入数据，遵循将“T”写入第一组盘，“E”写入第二组盘。再次将“C”写入第一组盘，“M”到第二组盘。

特点：  10：性能+，读写+，冗余+；  01： 性能+，读写+，冗余+；

良好的读写性能，总容量丢失一半的可用空间，容错，从副本数据中快速重建，由于其高性能和高可用性，常被用于数据库的存储中。

**5+0**： （至少6块）

  性能+，读写+

  冗余+

**JBOD技术**：适用于存储单个大文件，多个硬盘累加当成一块硬盘用

  性能0，读写0

  冗余0

（至少2块）

(ps:比如一块硬盘存储一个文件，这个文件的大小累计增长的，当文件大小达到硬盘容量后，这时可以在添加一块硬盘，然后使用JBOD技术，把新加的硬盘与原

硬盘合并成一整块硬盘。)

**总结：**

1.**RAID 0**

（1）将几块磁盘并行组合，横向写数据

（2）并发IO，写数据最快

缺点：不提供数据冗余，如果其中一块磁盘废掉，则数据全毁

详细：条带深度大时，一次IO只能从一块磁盘上读取，无性能提升。要在某种程度上提升性能，需要减小条带深度。

2.**RAID 1**

（1）一块磁盘写，另一块作为备份，也在相同的位置写。

（2）当一块磁盘废掉或者磁盘某区域坏掉，则读取另外一个磁盘。

（3）写性能等于最低那块硬盘的写性能。

优点：

（1）提供初步数据保护

（2）虽然额外多了一个操作，但是写速度也很快

缺点：

速度太慢，一个写另一个也必须写

与RAID 0的不同：

RAID 0没有数据保护措施，RAID 1数据有两份

3.**RAID 2**

（1）每两块数据盘就有一块校验盘(海明校验码)

（2）当数据损坏时通过校验码可恢复损坏磁盘上的数字，每次只能传输2路数据，因数据盘就两块。

（3）并存并取

缺点：

（1）数据存储时数据位被强行打散在两块磁盘上，每次读取数据都要两块磁盘联动

（2）利用海明码开销太大

详细：

4块数据盘，3块校验盘。假设RAID 2条带大小为4b（1b*4块），控制器接收到IO的数据之后第一块磁盘写入1 5 9 13等位，第二块磁盘写入2 6 10 14等位，第三第四块磁盘相同，此时全盘读写，数据物理不连续，逻辑连续，导致对非事务性IO效率低下。适合连续，大块IO的情况

与RAID 0的不同：

不能并发，每次IO都占据了所有磁盘；每次都保证所有磁盘运行

4.**RAID 3**

（1）只留一块校验盘，将数据每一位之间做异或XOR运算，任何一个扇区损坏通过剩余未和校验位一同进行异或运算，得到丢失位，8位一起校验则得到损坏的一个字节。

（2）条带深度小，将IO分成小块每个块4KB，让每个磁盘都有机会存储这些小块，这样多磁盘并行读写，性能高。

（3）XOR只能判断数据是否有误，不能修正数据

缺点：

校验盘会成为热点盘；每次IO都需要牵动所有磁盘，和RAID 一样，不适合并发IO

详细：

每一个条带设计为OS系统块的大小，深度随磁盘数量而定，最小为1个扇区；每个条带一般为OS系统块长度，写数据时按数据块分散到各个磁盘。

优化方案RAID 30采用8个数据盘，2个校验盘可以支持2个IO并发。

与RAID 2的不同：

RAID 2对扇区进行分散，RAID 3保留了扇区的物理连续，以一个或多个扇区为单位来分散数据。

5.**RAID 4**

（1）为了实现并发IO，需要保证有空闲的磁盘未被IO占用，以便其他的IO进行访问。

（2）如果IO块小于RAID 3的条带深度(横向写)，则数据纵向写，只放在一个磁盘上。

缺点：

校验盘无法并发，每次都读写，会成为热点盘，损坏几率大；写速度很慢

6.**RAID 5**

（1）是RAID 0和RAID 1的折中方案。

（2）将校验盘打散到各个盘之中，并发IO可以同时访问校验盘，克服了校验盘不能并发成为热点盘的缺点。

缺点：写惩罚高，根本原因在于每次扇区都要产生其校验区写入校验盘；每一次写都要先读出老数据，然后读校验数据，然后写新数据和校验数据；只能坏一块磁盘

详细：

校验segment循环分布在相邻条带上。为保证并发IO，将条带做的较大，以保证每次IO数据不会占满整个条带，造成其他IO等待。要保证高并发率，否则会转成读改写，写惩罚高。

7.**RAID 6**

（1）为了解决两块数据盘损坏无法恢复的情况

（2）布尔运算两个方程式，x XOR y = 1，Ax XOR Bx = 0，求解

缺点：比RAID 5多两个操作，多读一个校验数据，计算后还要写一次

二、整条写、重构写和读改写

1.整条写

每个条带上的segment都更新，不需要额外的读写操作，写性能最好

2.重构写

当需要写入的磁盘数目超过阵列磁盘的一半时采取该方式

（1）从不需要修改的segment中读取原来的数据，再和本条带中所有需要修改的segment上的新数据一起计算XOR校验值

（2）将新的segment数据和没有更新过的segment数据以及新的XOR校验值一起写入

例如：

数据盘为8块，某个时刻一个IO只更新了一个条带的6个segment，剩余两个没有更新。在重构写模式下，会将没有更新的两个segment数据读出，和需要更行的

前6个segment计算出校验数据，然后数据和校验信息一起写入磁盘

与整条写的比较：

多出读segment数据操作和写校验数据操作

3.读改写

当需要写入的磁盘数目不超过一半时采取

（1）从需要修改的segment中读取旧数据，再从条带上读取旧的奇偶校验值（读）

（2）根据旧数据、旧校验值和需要修改的segment上的新数据计算这个条带上的新校验值（改）

（3）写入新的数据和校验值（写）

示例：linux实现软RAID5：

1、准备硬盘（至少需要3块硬盘，此处使用一块硬盘的5个分区实现，但是在实际生产中一块硬盘做RAID没有意义）：

 

```
fdisk -cul /dev/sdb #创建分区如下
"""
/dev/sdb1 2048 10487807 5242880 83 Linux
/dev/sdb2 10487808 41943039 15727616 5 Extended
/dev/sdb5 10489856 16781311 3145728 83 Linux
/dev/sdb6 16783360 23074815 3145728 83 Linux
/dev/sdb7 23076864 29368319 3145728 83 Linux
/dev/sdb8 29370368 35661823 3145728 83 Linux
/dev/sdb9 35663872 41943039 3139584 83 Linux
"""

partx -a /dev/sdb #重新读取分区表

rpm -qa |grep mdadm #查看创建raid软件是否安装
```

 

```
fdisk -cul /dev/sdb #创建分区如下
"""
/dev/sdb1 2048 10487807 5242880 83 Linux
/dev/sdb2 10487808 41943039 15727616 5 Extended
/dev/sdb5 10489856 16781311 3145728 83 Linux
/dev/sdb6 16783360 23074815 3145728 83 Linux
/dev/sdb7 23076864 29368319 3145728 83 Linux
/dev/sdb8 29370368 35661823 3145728 83 Linux
/dev/sdb9 35663872 41943039 3139584 83 Linux
"""
partx -a /dev/sdb #重新读取分区表
rpm -qa |grep mdadm #查看创建raid软件是否安装
```

2、创建RAID 5

 

```
mdadm -C /dev/md0 -a yes -l 5 -n 4 -x 1 /dev/sdb{5..9} 

mdadm --detail /dev/md0 # 查看/dev/md0的详细信息

```

 

```
mdadm -C /dev/md0 -a yes -l 5 -n 4 -x 1 /dev/sdb{5..9} 
mdadm --detail /dev/md0 # 查看/dev/md0的详细信息
```

mdadm

参数说明：

-C：创建/dev/md0设备

-a：是否自动检测这里为yes

-l：raid的级别这里为raid5

-n：几块硬盘做为RUN

-x：几块硬盘作为备用