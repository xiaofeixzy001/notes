[TOC]

## 一，Linux核心进程管理命令

### 1.1 ps：查看进程

#### 1.1.1 命令解释

**功能说明**

> ps命令用于列出执行ps命令的那个时刻的进程快照，就像用手机给进程照了一张照片。如果想要动态地显示进程，就需要使用top命令，该命令类似于把手机切换成录像模式。

**选项说明**

| 参数选项  | 解释说明（带@的为重点）                             |
| --------- | --------------------------------------------------- |
| -a        | 显示所有终端下执行的进程                            |
| a         | 显示与终端相关的所有进程，包含每个进程的完整路径@   |
| x         | 显示与终端无关的所有进程@                           |
| u         | 显示进程的用户信息@                                 |
| -u        | 显示指定用户相关的进程信息                          |
| -e        | 显示所有进程@                                       |
| -f        | 额外显示UID，PPID，C与STIME栏位@                    |
| f         | 显示进程树                                          |
| -H        | 显示进程树                                          |
| -l        | 以详细的格式来显示进程的状况                        |
| -o        | 自定义输出指定的字段，以逗号分隔                    |
| -sort key | key表示为指定字段排序，默认升序，+key升序，-key降序 |

#### 1.1.2 使用范例

（1）ps 命令不接任何参数

```
[root@Mr_chen ~]# ps
   PID TTY          TIME CMD
  1135 pts/0    00:00:00 bash
  1152 pts/0    00:00:00 bash
  1162 pts/0    00:00:00 bash
  1173 pts/0    00:00:00 bash
  1182 pts/0    00:00:00 ps
```

> 默认情况下，ps命令不接任何参数时，输出的是使用者当前所在终端（窗口）的进程，其输出结果中的各项说明如下。

- [x] :PID是进程的标识号
- [x] :TTY是进程所属的终端控制台
- [x] :TIME列是进程所使用的总的CPU时间
- [x] :CMD列是正在执行的命令行

（2）ps -ef

```
[root@Mr_chen ~]# ps -ef    # -e显示所有进程，-f格外显示UID，PPID，C与STIME栏位
UID         PID   PPID  C STIME TTY          TIME CMD
root          1      0  0 15:00 ?        00:00:00 /sbin/init
root          2      0  0 15:00 ?        00:00:00 [kthreadd]
root          3      2  0 15:00 ?        00:00:00 [migration/0]
root          4      2  0 15:00 ?        00:00:00 [ksoftirqd/0]
root          5      2  0 15:00 ?        00:00:00 [migration/0]
root          6      2  0 15:00 ?        00:00:00 [watchdog/0]
root          7      2  0 15:00 ?        00:00:00 [events/0]
root          8      2  0 15:00 ?        00:00:00 [cgroup]
root          9      2  0 15:00 ?        00:00:00 [khelper]
root         10      2  0 15:00 ?        00:00:00 [netns]
root         11      2  0 15:00 ?        00:00:00 [async/mgr]
root         12      2  0 15:00 ?        00:00:00 [pm]
root         13      2  0 15:00 ?        00:00:00 [sync_supers]
root         14      2  0 15:00 ?        00:00:00 [bdi-default]
root         15      2  0 15:00 ?        00:00:00 [kintegrityd/0]
root         16      2  0 15:00 ?        00:00:00 [kblockd/0]
root         17      2  0 15:00 ?        00:00:00 [kacpid]
```

> 输出信息中各列说明如下

- [x] UID：进程被该UID所拥有
- [x] PID：进程的标识号
- [x] PPID：进程的父进程的标识号
- [x] C：CPU使用的资源百分比
- [x] STIME:进程开始的时间
- [x] TTY:该进程是在哪个终端机上面运作，若与终端机无关，则显示“？”，另外，tty1-tty6是本机上面的登入者进程，若为pts/0等，则表示为由网络连接进主机的进程。
- [x] TIME：进程所使用的总的CPU时间
- [x] CMD：正在执行的命令行

（3）ps aux

```
[root@Mr_chen ~]# ps aux
USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root          1  0.0  0.1  19232  1488 ?        Ss   15:00   0:00 /sbin/init
root          2  0.0  0.0      0     0 ?        S    15:00   0:00 [kthreadd]
root          3  0.0  0.0      0     0 ?        S    15:00   0:00 [migration/0]
root          4  0.0  0.0      0     0 ?        S    15:00   0:00 [ksoftirqd/0]
root          5  0.0  0.0      0     0 ?        S    15:00   0:00 [migration/0]
root          6  0.0  0.0      0     0 ?        S    15:00   0:00 [watchdog/0]
root          7  0.0  0.0      0     0 ?        S    15:00   0:00 [events/0]
```

> 输出信息中各列的说明如下

- [x] USER:该进程属于的用户。
- [x] PID：该进程的进程号。
- [x] %CPU：该进程使用掉的CPU资源百分比。
- [x] %MEM：该进程所占用的物理内存百分比。
- [x] VSZ：该进程使用掉的虚拟内存量（单位Kbytes）
- [x] RSS：该进程占用的固定的内存量（单位Kbytes）
- [x] TTY：该进程是在哪个终端机上面运作的，若与终端机无关，则显示“？”，另外，tty1-tty6是本机上面的登入者进程，若为pts/0等，则表示为由网络连接进主机的进程。
- [x] STAT：该进程目前的状态，主要的状态包括如下几种。
  - R：正在运行，或者是可以运行。
  - S：正在终端睡眠中，可以由某些信号唤醒。
  - D：不可中断睡眠。
  - T：正在侦测或者是停止了。
  - Z：已经终止，但是其父进程无法正常终止它，从而变成zombie（僵尸）进程的状态
  - +：前台进程。
  - l：多线程进程。
  - N：低优先级进程。
  - <：高优先级进程。
  - s：进程领导者。
  - L：已将页面锁定到内存中。
- [x] START：该进程被触发启动的时间
- [x] TIME：该进程实际使用CPU运作的时间
- [x] COMMAND：该进程的实际命令。

（4）显示指定用户的相关进程信息

```
[root@Mr_chen ~]# ps -u yunjisuan
   PID TTY          TIME CMD
  1315 pts/1    00:00:00 bash
  1335 pts/1    00:00:00 vim
```

（5） 以详细格式显示进程状态

```
[root@Mr_chen ~]# ps -u yunjisuan -l
F S   UID    PID   PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S   500   1315   1314  0  80   0 - 27076 n_tty_ pts/1    00:00:00 bash
0 T   500   1335   1315  0  80   0 - 35884 signal pts/1    00:00:00 vim
```

> 输出信息中各列的说明如下

- [x] F:代表这个进程的标志（flag），4代表使用者为super user。
- [x] S：代表这个进程的状态（STAT），前面已经讲解过了
- [x] UID:进程被该UID所拥有。
- [x] PID：进程的标识号。
- [x] PPID：父进程的ID。
- [x] C：CPU使用的资源百分比。
- [x] PRI：Priority（优先执行序）的缩写
- [x] NI：Nice值
- [x] ADDR:指出该进程在内存的哪个部分。如果是个running的进程，则一般是“-”。
- [x] SZ:使用掉的内存大小。
- [x] WCHAN:目前这个进程是否正在运作当中，若为“-”则表示正在运作。
- [x] TTY:该进程是在哪个终端机上面运作的，若与终端机无关，则显示“？”，另外，tty1-tty6是本机上面的登入者进程，若为pts/0等，则表示为由网络连接进主机的进程。
- [x] TIME：该进程实际使用CPU运作的时间
- [x] CMD：该进程的实际命令

（6）查看某个进程在哪个CPU上运行

```
[root@Mr_chen ~]# ps -eo pid,args,psr
   PID COMMAND                     PSR
     1 /sbin/init                    0  #CPU标记0代表第一个CPU
     2 [kthreadd]                    0
     3 [migration/0]                 0
     4 [ksoftirqd/0]                 0
     5 [migration/0]                 0
     6 [watchdog/0]                  0
     7 [events/0]                    0
     8 [cgroup]                      0
     9 [khelper]                     0
```

### 1.2 kill:终止进程

#### 1.2.1 命令解释

**功能说明**

> kill命令能够终止你希望停止的进程

**选项说明**

| 参数选项 | 解释说明（带@为重点）                                |
| -------- | ---------------------------------------------------- |
| -l       | 列出全部的信号名称                                   |
| -p       | 指定kill命令只打印相关进程的进程号，而不发送任何信号 |
| -s       | 指定要发送的信号@                                    |

#### 1.2.2 使用范例

（1）列出所有信号的名称

```
[root@Mr_chen ~]# kill -l
 1) SIGHUP   2) SIGINT   3) SIGQUIT  4) SIGILL   5) SIGTRAP
 6) SIGABRT  7) SIGBUS   8) SIGFPE   9) SIGKILL 10) SIGUSR1
11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP
21) SIGTTIN 22) SIGTTOU 23) SIGURG  24) SIGXCPU 25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF 28) SIGWINCH    29) SIGIO   30) SIGPWR
31) SIGSYS  34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX    
[root@Mr_chen ~]# kill -l kill  #可以使用-l参数对信号名和数字信号互换
9
[root@Mr_chen ~]# kill -l 9
KILL
```

**常用信号：**

| 信号       | 说明                                                 |
| ---------- | ---------------------------------------------------- |
| HUP（1）   | 挂起，通常因终端掉线或用户退出而引发                 |
| INT（2）   | 中断，通常是按下Ctrl+c组合键来发出这个信号           |
| QUIT（3）  | 退出，通常是按下CTRL+\组合键来发出这个信号           |
| KILL（9）  | 立即结束进程的运行                                   |
| TERM（15） | 终止，通常在系统关机时发送                           |
| TSTP（20） | 暂停进程的运行，通常是按下Ctrl+z组合键来发出这个信号 |

（2）终止进程

> - kill指令默认使用的信号为15，用于结束进程。如果进程忽略此信号，则可以使用信号9强制终止进程。
> - 一般是先通过ps等命令获取到要终止进程的进程号，然后直接使用“kill 进程号”就可以了。

```
kill 2203   #kill 命令默认使用的信号为15，这种格式最常用、
kill -s 15 2203 #这种格式使用-s参数明确指定发送值为15的信号，效果和kill 2203一样
kill -15 2203   #上面的-s 15可以简写为-15
```

如果用上面的方法还是无法终止进程，那么我们就可以用KILL（9）信号强制终止进程。

```
kill -9 2203    #信号9会强行终止进程，这会带来一些副作用，如数据丢失，或者终端无法恢复到正常状态等，因此应尽量避免使用，除非进程使用其他信号无法终止。
```

（3）扩展：特殊信号0的应用案例

> 在kill的所有信号中，有一个十分特殊的信号值0，使用格式为kill -0 $pid。其中的-0表示不发送任何信号给$pid对应的进程，但是仍然会对$pid是否存在对应的进程进行检查，如果$pid对应的进程已存在，则返回0，若不存在则返回1。

```
[root@Mr_chen ~]# pgrep -l sshd
985 sshd
1131 sshd
[root@Mr_chen ~]# kill -s 0 985
[root@Mr_chen ~]# echo $?
0
[root@Mr_chen ~]# kill -s 0 986
bash: kill: (986) - No such process
[root@Mr_chen ~]# echo $?
1
```

> 应用：如果同学们想要写一个管理系统服务的脚本，则可以使用这个技巧。

### 1.3 killall:通过进程名终止进程

#### 1.3.1 命令解释

**功能说明：**

> 使用kill命令终止进程还需要先获取进程的pid进程号，这个过程有点繁琐，而使用killall命令就可以直接用“kill 进程名”这种形式终止进程。

**选项说明：**

| 参数选项 | 解释说明（带@为重点）                                        |
| -------- | ------------------------------------------------------------ |
| -I       | 不区分大小写匹配                                             |
| -g       | 终止属于该进程组的进程                                       |
| -i       | 在终止进程之前询问是否确认                                   |
| -l       | 列出所有已知的信号名                                         |
| -q       | 如果没有进程终止则不提示                                     |
| -r       | 使用正则表达式匹配要终止的进程名称                           |
| -s       | 用指定的信号代替默认信号                                     |
| -u       | 终止指定用户的进程@                                          |
| -v       | 报告信号是否发送成功                                         |
| -w       | 等待所有被终止的进程死去。killall每秒都会检查一次被终止的进程是否仍然存在，其仅在都死光后才返回。注意，如果信号被忽略，或者没有起作用，或者进程停留在僵尸状态，那么killall可能会永久等待@ |

#### 1.3.2 使用范例

（1）终止定时任务服务进程的例子

首先我们要知道定时任务的进程名是crond，终止该进程的命令如下：

```
[root@Mr_chen ~]# killall crond
[root@Mr_chen ~]# killall crond #用killall终止进程可执行多次
crond: no process killed    #等看到这个结果说明进程死了
[root@Mr_chen ~]# 
[root@Mr_chen ~]# /etc/init.d/crond start   #启动服务
Starting crond:                                            [  OK  ]
[root@Mr_chen ~]# killall -w crond  #使用-w参数，会看到等待几秒后结束命令操作
[root@Mr_chen ~]# killall -w crond
crond: no process killed
```

（2）终止指定用户的所有进程

```
[root@Mr_chen ~]# ps -u yunjisuan -l    #查看普通用户的所有进程详细信息
F S   UID    PID   PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S   500   1175   1174  0  80   0 - 27076 wait   pts/1    00:00:00 bash
0 S   500   1210   1175  0  80   0 - 27076 n_tty_ pts/1    00:00:00 bash
0 T   500   1235   1210  0  80   0 - 35884 signal pts/1    00:00:00 vim
[root@Mr_chen ~]# killall -u yunjisuan vim  #杀掉指定用户的vim进程
[root@Mr_chen ~]# ps -u yunjisuan -l    #成功
F S   UID    PID   PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S   500   1175   1174  0  80   0 - 27076 wait   pts/1    00:00:00 bash
0 S   500   1210   1175  0  80   0 - 27076 n_tty_ pts/1    00:00:00 bash
```

> **特别提示：**
>  这种方式可以终止所有归属于yunjisuan用户的vim进程。在之前，我在给同学们讲nginx优化时提到过nginx的监牢模式和在和给同学们讲解sudo时提到过企业的集权分治策略，他们都是利用普通用户来启动服务。此时，我们可以指定用户杀死该用户启动的某一服务的所有进程。

### 1.4 pkill：通过进程名终止进程

#### 1.4.1 命令解释

**功能说明：**

> pkill命令可通过进程名终止指定的进程。使用killall终止进程需要连续执行几次，而pkill可以杀死指定进程及其所有子进程。

**选项说明：**

| 参数选项 | 解释说明（带@为重点） |
| -------- | --------------------- |
| -t终端   | 杀死指定终端的进程@   |
| -u用户   | 杀死指定用户的进程@   |

#### 1.4.2 使用范例

（1）通过进程名终止进程

```
[root@Mr_chen ~]# /etc/init.d/crond status  #查看定时任务程序运行状态
crond (pid  1274) is running...
[root@Mr_chen ~]# pkill crond   #终止定时任务进程
[root@Mr_chen ~]# /etc/init.d/crond status  
crond dead but subsys locked    #进程被终止
```

（2）通过终端名终止进程

```
[root@Mr_chen ~]# w     #第二列TTY就是用户运行的终端
 15:57:09 up  1:05,  3 users,  load average: 0.00, 0.00, 0.00
USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT
yunjisua tty1     -                15:55   12.00s  0.02s  0.01s vim ttt
root     pts/0    192.168.200.1    14:51    0.00s  0.07s  0.00s w
root     pts/1    192.168.200.1    15:19    3:28   0.01s  0.00s bash
[root@Mr_chen ~]# ps -u yunjisuan -l    #查看用户的进程
F S   UID    PID   PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S   500   1175   1174  0  80   0 - 27076 wait   pts/1    00:00:00 bash
0 S   500   1210   1175  0  80   0 - 27076 n_tty_ pts/1    00:00:00 bash
4 S   500   1333   1322  0  80   0 - 27075 wait   tty1     00:00:00 bash
0 S   500   1359   1333  0  80   0 - 35890 poll_s tty1     00:00:00 vim
[root@Mr_chen ~]# pkill -t tty1     #杀掉终端正在运行的进程
[root@Mr_chen ~]# ps -u yunjisuan -l    #vim进程没了
F S   UID    PID   PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S   500   1175   1174  0  80   0 - 27076 wait   pts/1    00:00:00 bash
0 S   500   1210   1175  0  80   0 - 27076 n_tty_ pts/1    00:00:00 bash
4 S   500   1333   1322  0  80   0 - 27075 n_tty_ tty1     00:00:00 bash
[root@Mr_chen ~]# pkill -9 -t tty1  #强行杀掉tty1终端（踢掉用户）
[root@Mr_chen ~]# ps -u yunjisuan -l
F S   UID    PID   PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S   500   1175   1174  0  80   0 - 27076 wait   pts/1    00:00:00 bash
0 S   500   1210   1175  0  80   0 - 27076 n_tty_ pts/1    00:00:00 bash
[root@Mr_chen ~]# w     #tty1终端没了
 15:58:17 up  1:06,  2 users,  load average: 0.00, 0.00, 0.00
USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT
root     pts/0    192.168.200.1    14:51    0.00s  0.08s  0.00s w
root     pts/1    192.168.200.1    15:19    4:36   0.01s  0.00s bash
```

（3）通过用户名终止进程

```
[root@Mr_chen ~]# w
 16:08:24 up  1:16,  3 users,  load average: 0.00, 0.00, 0.00
USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT
yunjisua tty1     -                16:01    4.00s  0.03s  0.02s -bash
root     pts/0    192.168.200.1    14:51    0.00s  0.09s  0.00s w
root     pts/1    192.168.200.1    15:19   14:43   0.01s  0.00s bash
[root@Mr_chen ~]# ps -u yunjisuan -l    #查看用户的进程信息
F S   UID    PID   PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S   500   1175   1174  0  80   0 - 27076 wait   pts/1    00:00:00 bash
0 S   500   1210   1175  0  80   0 - 27076 n_tty_ pts/1    00:00:00 bash
4 S   500   1387   1366  0  80   0 - 27076 n_tty_ tty1     00:00:00 bash
0 T   500   1430   1387  0  80   0 - 35883 signal tty1     00:00:00 vim
[root@Mr_chen ~]# pkill -u yunjisuan    #杀掉指定用户所有进程
[root@Mr_chen ~]# ps -u yunjisuan -l    #成功
F S   UID    PID   PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S   500   1175   1174  0  80   0 - 27076 wait   pts/1    00:00:00 bash
0 S   500   1210   1175  0  80   0 - 27076 n_tty_ pts/1    00:00:00 bash
4 S   500   1387   1366  0  80   0 - 27076 n_tty_ tty1     00:00:00 bash
```

### 1.5 top：实时显示系统中各个进程的资源占用状况

#### 1.5.1 命令解释

**功能说明：**

> top命令用于实时地对系统处理器状态进行监控，它能够实时地显示系统中各个进程的资源占用状况。该命令可以按照CPU的使用，内存的使用和执行时间对系统任务进程进行排序显示，同时top命令还可以通过交互式命令进行设定显示。

**选项说明：**

| 参数选项 | 解释说明（带@为重点）                                        |
| -------- | ------------------------------------------------------------ |
| -a       | 将进程按照使用内存排序                                       |
| -b       | 以批处理的模式显示进程信息，输出结果可以传递给其他程序或写入到文件中。在这种模式下，top命令不会接受任何输入，一直运行直到达到-n选项设置的阈值，或者按Ctrl+C等组合键终止程序 |
| -c       | 显示进程的整个命令路径，而不是只显示命令名称                 |
| -d       | 指定每两次屏幕信息刷新之间的时间间隔                         |
| -H       | 指定这个可以显示每个线程的情况，否则就是进程的总的状态       |
| -i       | 不显示闲置或者僵死的进程信息                                 |
| -n       | top输出信息更新的次数，完成后将退出top命令                   |
| -p       | 显示指定的进程信息                                           |

#### 1.5.2 使用范例

（1）显示进程信息

```
root@Mr_chen ~]# top        #使用top命令通常不接任何参数
top - 16:40:31 up  1:48,  3 users,  load average: 0.00, 0.00, 0.00
Tasks:  77 total,   1 running,  76 sleeping,   0 stopped,   0 zombie
Cpu(s):  0.0%us,  0.0%sy,  0.0%ni,100.0%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
Mem:   1004412k total,   152112k used,   852300k free,    11312k buffers
Swap:  2031608k total,        0k used,  2031608k free,    42304k cached

   PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                 
     1 root      20   0 19232 1536 1256 S  0.0  0.2   0:00.76 init                      
     2 root      20   0     0    0    0 S  0.0  0.0   0:00.00 kthreadd                  
     3 root      RT   0     0    0    0 S  0.0  0.0   0:00.00 migration/0               
     4 root      20   0     0    0    0 S  0.0  0.0   0:00.01 ksoftirqd/0
```

- 第一行，任务队列信息，同uptime命令的执行结果
  - [x] 16:40:31 当前系统时间
  - [x] up 1:48 系统已经运行了1小时48分
  - [x] 3 users 当前有2个用户登录系统
  - [x] load average:0.00, 0.00, 0.00 load average后面三个数分别是1分钟、5分钟、15分钟的平均负载情况
- 第二行，Tasks为任务（进程）。从上面的信息可以看出，系统现在共有77个进程，其中处于运行状态的有1个，76个在休眠（sleep），stoped状态0个，zombie状态（僵死）的有0个。
- 第三行，CPU状态信息
  - [x] 0.0%us 用户空间占用CPU的百分比
  - [x] 0.0%sy 内核空间占用CPU的百分比
  - [x] 0.0%ni 改变过优先级的进程占用CPU的百分比
  - [x] 100.0%id 空闲CPU百分比
  - [x] 0.0%wa I/O等待占用CPU的百分比
  - [x] 0.0%hi 硬中断（Hardware IRQ）占用CPU的百分比
  - [x] 0.0%si 软中断（Software Interrupts）占用CPU的百分比
  - [x] 0.0%st 虚拟机占用CPU的百分比
- 第四行，内存状态
  - [x] 1004412k total 物理内存总量
  - [x] 152112k used 使用中的内存总量
  - [x] 852300k free 空闲内存总量
  - [x] 11312k buffers 缓冲的内存量
- 第五行，swap交换分区信息
  - [x] 2031608k total 交换区总量
  - [x] 0k used 使用的交换区总量
  - [x] 2031608k free 空闲交换区总量
  - [x] 42304k cached 缓存的内存量
- 第六行，空行
- 第七行开始，给出的是各进程（任务）的状态监控
  - [x] PID 进程id
  - [x] USER 进程所有者
  - [x] PR 进程优先级
  - [x] NI nice值，负值表示高优先级，正值表示低优先级。
  - [x] VIRT 进程使用的虚拟内存总量，单位kb。
  - [x] RES 进程使用的、未被换出的物理内存大小，单位为kb。
  - [x] SHR 共享内存大小，单位为kb
  - [x] S 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程
  - [x] %CPU 上次更新到现在的CPU时间占用百分比
  - [x] %MEM 进程使用的物理内存百分比
  - [x] TIME+ 进程使用的CPU时间总计，单位1/100秒
  - [x] COMMAND 进程名称（命令名/命令行）

> **特别提示：**
>  1）计算真正可用的内存数为：第四行的free+第四行的buffers+第五行的cached
>  2）在对内存进行监控时，我们要时刻关注top命令里第五行swap交换分区的used，如果这个数值还在不断地变化，则说明内核正在不断进行内存和swap的数据交换，这表示内存真的不够用了或者程序运行有内存溢出问题。

（2）显示多核不同核CPU的信息

> 在top基本视图中，按键盘数字“1”，可监控每个逻辑CPU的状况。

```
![1.png-42.8kB][2]
```

> 从上图可以发现，服务器有8个逻辑CPU，实际上是2个物理CPU。再按数字键1，就会返回到top基本视图界面。

（2）将进程按照使用内存排序。

```
[root@Mr_chen ~]# top -a    #使用参数-a将进程按照使用内存排序
top - 18:07:36 up 42 min,  1 user,  load average: 0.00, 0.00, 0.00
Tasks: 164 total,   1 running, 163 sleeping,   0 stopped,   0 zombie
Cpu(s):  0.0%us,  0.0%sy,  0.0%ni,100.0%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
Mem:   1004412k total,   153948k used,   850464k free,    10296k buffers
Swap:  2031608k total,        0k used,  2031608k free,    37868k cached

   PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                 
  1236 root      20   0 98.0m 4036 3056 S  0.0  0.4   0:00.20 sshd                     
  1209 postfix   20   0 81524 3424 2544 S  0.0  0.3   0:00.01 qmgr                     
  1202 root      20   0 81272 3400 2496 S  0.0  0.3   0:00.03 master                   
  1208 postfix   20   0 81352 3380 2504 S  0.0  0.3   0:00.03 pickup  
```

（3）以批处理模式显示进程信息

```
[root@Mr_chen ~]# top -b        #使用参数-b可以看到命令执行结果不停地向下刷新
......
  1229 root      20   0  4064  576  496 S  0.0  0.1   0:00.00 mingetty                 
  1231 root      20   0  4064  576  496 S  0.0  0.1   0:00.00 mingetty                 
  1233 root      20   0  4064  576  496 S  0.0  0.1   0:00.00 mingetty                 
  1235 root      20   0  4064  576  496 S  0.0  0.1   0:00.00 mingetty                 
  1236 root      20   0 98.0m 4036 3056 S  0.0  0.4   0:00.22 sshd                     
  1243 root      18  -2 12344 2580  516 S  0.0  0.3   0:00.00 udevd                    
  1244 root      18  -2 12344 2584  516 S  0.0  0.3   0:00.00 udevd                    
  1248 root      20   0  105m 1876 1520 S  0.0  0.2   0:00.04 bash                     
  1301 root      20   0 17384  668  452 S  0.0  0.1   0:00.00 anacron                  
  1318 root      20   0 15032 1340  984 R  0.0  0.1   0:00.01 top                      
^C  #退出使用快捷键Ctrl+C
```

（4）显示进程的完整路径

```
[root@Mr_chen chen]# top -c #使用参数-c显示进程的整个命令路径。
top - 18:19:38 up 54 min,  1 user,  load average: 0.00, 0.00, 0.00
Tasks: 164 total,   1 running, 163 sleeping,   0 stopped,   0 zombie
Cpu(s):  0.0%us,  0.0%sy,  0.0%ni,100.0%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
Mem:   1004412k total,   154196k used,   850216k free,    10316k buffers
Swap:  2031608k total,        0k used,  2031608k free,    37904k cached

   PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                 
     1 root      20   0 19232 1484 1220 S  0.0  0.1   0:00.98 /sbin/init               
     2 root      20   0     0    0    0 S  0.0  0.0   0:00.01 [kthreadd]               
     3 root      RT   0     0    0    0 S  0.0  0.0   0:00.00 [migration/0] 
```

（5） 设置执行top命令后的信息刷新时间

```
[root@Mr_chen chen]# top -d 3       #使用参数-d指定更新周期为3秒，也就是说命令结果每隔3s刷新一次
```

（6）设置执行top命令后的信息刷新次数

```
[root@Mr_chen chen]# top -n 2   #使用参数-n指定更新次数为2次，也就是说命令结果刷新两次后终止退出，-n参数可以和-b参数配合使用
```

（7）将top输出结果的全部信息输出到文件中

```
[root@Mr_chen chen]# top -b -n1 > test  #以批处理方式，就刷新1次数据重定向到文件里
[root@Mr_chen chen]# cat test | wc -l
171
[root@Mr_chen chen]# top -n1 > test     #如果不是批处理方式，数据量少
[root@Mr_chen chen]# cat test | wc -l
28
```

> **特别提示：**
>  在工作中，如果没有必要，我们尽量不要在服务器上直接用top无任何参数的方式查看，因为这样会非常占用系统的资源。我们可以使用`top -b -n1 > test`的方式将数据重定向到文件里，再进行查看。

（8）显示指定的进程信息

```
[root@Mr_chen chen]# top -p 1126    #使用-p选项显示指定进程号的信息
top - 18:31:18 up  1:06,  1 user,  load average: 0.00, 0.00, 0.00
Tasks:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie
Cpu(s):  0.0%us,  0.0%sy,  0.0%ni,100.0%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
Mem:   1004412k total,   154032k used,   850380k free,    10448k buffers
Swap:  2031608k total,        0k used,  2031608k free,    38060k cached

   PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                 
  1126 root      20   0 66604 1184  468 S  0.0  0.1   0:00.00 sshd 
```

（9）显示指定用户的信息

```
[root@Mr_chen chen]# top -u yunjisuan   #使用-u参数显示指定用户的进程信息
top - 18:33:05 up  1:08,  2 users,  load average: 0.00, 0.00, 0.00
Tasks: 165 total,   1 running, 164 sleeping,   0 stopped,   0 zombie
Cpu(s):  0.0%us,  0.0%sy,  0.0%ni,100.0%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
Mem:   1004412k total,   160388k used,   844024k free,    10796k buffers
Swap:  2031608k total,        0k used,  2031608k free,    41696k cached

   PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                 
  1384 yunjisua  20   0  105m 1896 1528 S  0.0  0.2   0:00.01 bash                     
  1403 yunjisua  20   0  140m 3968 2684 S  0.0  0.4   0:00.01 vim   
```

### 1.6 nohup：用户退出系统进程继续工作

#### 1.6.1 命令解释

**功能说明：**

> - nohup命令可以将程序以忽略挂起信号的方式运行起来，被运行程序的输出信息将不会显示到终端。
> - 无论是否将nohup命令的输出重定向到终端，输出都将写入到当前目录的nohup.out文件中。如果当前目录的nohup.out文件不可写，则输出重定向到$HOME/nohup.out文件中。

#### 1.6.2 使用范例

（1）让执行的命令在当前会话终止后继续保持运行。

> 正常情况下，如果用户退出登录或会话终止，则用户正在执行并可持续一段时间的命令（非守护进程）将自动终止。使用nohup命令可以实现在用户退出或当前会话终止后继续保持运行，具体的例子如下：

```
[root@Mr_chen ~]# cd chen/
[root@Mr_chen chen]# nohup ping www.baidu.com   #让当前执行的进程始终运行，关闭界面也不消失
nohup: ignoring input and appending output to `nohup.out'
^C[root@Mr_chen chen]# ls
nohup.out  test
[root@Mr_chen chen]# cat nohup.out #命令的执行记录会被记录在当前目录下的nohup.out中
PING www.a.shifen.com (61.135.169.125) 56(84) bytes of data.
64 bytes from 61.135.169.125: icmp_seq=1 ttl=128 time=4.22 ms
64 bytes from 61.135.169.125: icmp_seq=2 ttl=128 time=4.28 ms
64 bytes from 61.135.169.125: icmp_seq=3 ttl=128 time=4.20 ms
64 bytes from 61.135.169.125: icmp_seq=4 ttl=128 time=4.21 ms
64 bytes from 61.135.169.125: icmp_seq=5 ttl=128 time=4.16 ms
64 bytes from 61.135.169.125: icmp_seq=6 ttl=128 time=4.11 ms
64 bytes from 61.135.169.125: icmp_seq=7 ttl=128 time=4.22 ms
64 bytes from 61.135.169.125: icmp_seq=8 ttl=128 time=4.18 ms
64 bytes from 61.135.169.125: icmp_seq=9 ttl=128 time=4.21 ms

--- www.a.shifen.com ping statistics ---
9 packets transmitted, 9 received, 0% packet loss, time 8508ms
rtt min/avg/max/mdev = 4.114/4.203/4.285/0.097 ms
```

> 在工作中我们一般会配合&符号运行nohup命令，让程序直接在后台运行

```
[root@Mr_chen chen]# w  #用户yunjisuan的客户端已经退出
 05:45:29 up 8 min,  1 user,  load average: 0.00, 0.02, 0.00
USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT
root     pts/0    192.168.200.1    05:37    0.00s  0.12s  0.00s w
[root@Mr_chen chen]# ps -u yunjisuan -l #但是用户的ping进程还在
F S   UID    PID   PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S   500   1332      1  0  80   0 - 27394 poll_s ?        00:00:00 ping
[root@Mr_chen chen]# tail -f /home/yunjisuan/nohup.out #nohup.out文件一直在记录信息
64 bytes from 61.135.169.125: icmp_seq=24 ttl=128 time=4.26 ms
64 bytes from 61.135.169.125: icmp_seq=25 ttl=128 time=4.24 ms
64 bytes from 61.135.169.125: icmp_seq=26 ttl=128 time=4.14 ms
64 bytes from 61.135.169.125: icmp_seq=27 ttl=128 time=4.28 ms
64 bytes from 61.135.169.125: icmp_seq=28 ttl=128 time=6.25 ms
64 bytes from 61.135.169.125: icmp_seq=29 ttl=128 time=4.10 ms
```

### 1.7 strace:跟踪进程的系统调用

#### 1.7.1 命令解释

**功能说明**

> strace是Linux环境下的一款程序调试工具，用于检查一个应用程序所使用的系统调用以及它所接收的系统信息。strace会追踪程序运行时的整个生命周期，输出每一个系统调用的名字、参数、返回值和执行所消耗的时间等，是高级运维和开发人员排查问题的杀手锏。

**选项说明**

| 参数选项    | 解释说明（带@为重点）                                        |
| ----------- | ------------------------------------------------------------ |
| -c          | 统计每一个系统调用所执行的算时间、次数和出错的次数等         |
| -d          | 输出strace关于标准错误的调试信息                             |
| -f          | 跟踪目标进程，以及目标进程创建的所有子进程@                  |
| -ff         | 如果提供-o filename，则将所有进程的跟踪结果输出到相应的filename.pid中，pid是各进程的进程号 |
| -i          | 输出系统调用的入口指针                                       |
| -q          | 禁止输出关于脱离的消息                                       |
| -r          | 输出每一个系统调用的相对时间                                 |
| -t          | 在输出中的每一行前加上时间信息。例如：16:45:28               |
| -tt         | 在输出中的每一行前加上时间信息，精确到微秒。例如11:18:59.759546@ |
| -ttt        | 在输出中的每一行前加上时间信息，精确到微秒，而且时间表示为UNIX时间戳。例如1486111461.650434 |
| -T          | 显示每次系统调用所花费的时间                                 |
| -v          | 对于某些相关调用，把完整的环境变量、文件stat结构等打印出来   |
| -x          | 以十六进制形式输出非标准字符串                               |
| -xx         | 所有字符串以十六进制形式输出                                 |
| -o filename | 将strace的输出写入文件filename                               |
| -p pid      | 指定要跟踪的进程pid，要同时跟踪多个pid，重复多次-p选项即可@  |
| -s strsize  | 指定输出的字符串的最大长度，默认为32.并没有将文件名视为字符串，默认全部输出 |
| -u username | 以username的UID和GID执行所跟踪的命令                         |

**输出过滤器**

| 参数选项         | 解释说明（带@为重点）                                   |
| ---------------- | ------------------------------------------------------- |
| -e expr          | 输出过滤器，通过表达式，可以过滤掉你不想要的输出@       |
| -e trace=open    | 表示只跟踪open调用而-e trace！=open表示跟踪除open外所有 |
| -e trace=file    | 只跟踪与文件操作有关的系统调用                          |
| -e trace=process | 只跟踪与进程有关的系统调用                              |
| -e trace=network | 只跟踪与网络有关的系统调用                              |
| -e trace=signal  | 只跟踪与系统信号有关的系统调用                          |
| -e trace=desc    | 只跟踪与文件描述符有关的系统调用                        |
| -e trace=ipc     | 只跟踪与进程通信有关的系统调用                          |

#### 1.7.2 使用范例

（1）排查Nginx 403 forbidden错误

```
[root@localhost tmp]# strace -tt -f -o /tmp/test.txt /usr/local/nginx/sbin/nginx     #f参数跟踪目标进程，以及目标进程创建的所有子进程，-tt参数在输出中的每一行前加上时间信息，-o将跟踪内容输出到文件里。
[root@localhost tmp]# cat test.txt 
3824  05:37:14.300486 prctl(PR_SET_DUMPABLE, 1) = 0
3824  05:37:14.300498 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
3824  05:37:14.300518 epoll_create(512) = 8
3824  05:37:14.300535 eventfd2(0, 0)    = 9
3824  05:37:14.300549 epoll_ctl(8, EPOLL_CTL_ADD, 9, {EPOLLIN|EPOLLET, {u32=7095968, u64=7095968}}) = 0
3824  05:37:14.300569 mmap(NULL, 233472, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f73714f7000
3824  05:37:14.300607 brk(0x1fa5000)    = 0x1fa5000
3824  05:37:14.300693 epoll_ctl(8, EPOLL_CTL_ADD, 6, {EPOLLIN|0x2000, {u32=1901031440, u64=140133798998032}}) = 0
3824  05:37:14.300712 close(3)          = 0
3824  05:37:14.300724 epoll_ctl(8, EPOLL_CTL_ADD, 7, {EPOLLIN|0x2000, {u32=1901031664, u64=140133798998256}}) = 0
3824  05:37:14.300742 epoll_wait(8,     #epoll_wait表示等待连接访问，因此后面的输出都是和前一次访问有关的，下面我们仔细看一下日志输出。
```

**我们先将test.txt文件的内容清空，然后模拟去访问nginx**

```
[root@localhost tmp]# cat test.txt 
{{EPOLLIN, {u32=1901031440, u64=140133798998032}}}, 512, 4294967295) = 1
3824  05:57:59.271342 accept4(6, {sa_family=AF_INET, sin_port=htons(64469), sin_addr=inet_addr("192.168.0.254")}, [16], SOCK_NONBLOCK) = 3
3824  05:57:59.271383 epoll_ctl(8, EPOLL_CTL_ADD, 3, {EPOLLIN|EPOLLET|0x2000, {u32=1901031888, u64=140133798998480}}) = 0
3824  05:57:59.271401 epoll_wait(8, {{EPOLLIN, {u32=1901031888, u64=140133798998480}}}, 512, 60000) = 1
3824  05:57:59.271423 recvfrom(3, "GET / HTTP/1.1\r\nHost: 192.168.0."..., 1024, 0, NULL, NULL) = 308        #recvfrom接收到get请求
3824  05:57:59.271483 stat("/usr/local/nginx/html/www/index.html", 0x7fff69246350) = -1 ENOENT (No such file or directory)     #查看index.html文件不存在
3824  05:57:59.271506 stat("/usr/local/nginx/html/www", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
3824  05:57:59.271525 stat("/usr/local/nginx/html/www/index.htm", 0x7fff69246350) = -1 ENOENT (No such file or directory)     #查看index.htm文件不存在
#下面向用户返回403错误，并写入错误日志
3824  05:57:59.271546 write(5, "2018/01/14 05:57:59 [error] 3824"..., 200) = 200
3824  05:57:59.271587 writev(3, [{"HTTP/1.1 403 Forbidden\r\nServer: "..., 155}, {"<html>\r\n<head><title>403 Forbidd"..., 116}, {"<hr><center>nginx/1.10.2</center"..., 53}], 3) = 324
3824  05:57:59.271674 write(4, "192.168.0.254 - - [14/Jan/2018:0"..., 151) = 151
3824  05:57:59.271693 setsockopt(3, SOL_TCP, TCP_NODELAY, [1], 4) = 0
3824  05:57:59.271708 recvfrom(3, 0x1f3e190, 1024, 0, 0, 0) = -1 EAGAIN (Resource temporarily unavailable)
3824  05:57:59.271722 epoll_wait(8, 
#从上面的日志输出中，我们可以得知是因为2个文件不存在导致的403错误，因此我们检查配置文件就很容易发现问题。
    server {
        listen       80;
        server_name  www.yunjisuan.com;
        location / {
            root   html/www;
            index  index.html index.htm;        #这里缺少了设置首页文件
        }
    }
```

（2）只跟踪与文件操作有关的系统调用

> 如果命令结果的输出实在太多了，很容易看花眼，因此可以使用过滤器，过滤掉无关的信息，比如只查看文件操作信息。

```
[root@localhost tmp]# strace -tt -f -e trace=file -o /tmp/test.txt /usr/local/nginx/sbin/nginx
[root@localhost tmp]# cat test.txt 
3860  06:28:42.306924 stat("/usr/local/nginx/html/www/index.html", 0x7fff3ce39670) = -1 ENOENT (No such file or directory)
3860  06:28:42.306973 stat("/usr/local/nginx/html/www", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
3860  06:28:42.306994 stat("/usr/local/nginx/html/www/index.htm", 0x7fff3ce39670) = -1 ENOENT (No such file or directory)
```

（3）通过pid跟踪进程

```
[root@localhost tmp]# /usr/local/nginx/sbin/nginx   #启动nginx服务
[root@localhost tmp]# pgrep nginx -l
3873 nginx  #nginx的master进程
3874 nginx  #nginx的worker进程
[root@localhost tmp]# strace -tt -f -e trace=file -p 3874   #使用-p参数，只跟踪worker进程，结果更加精简
Process 3874 attached - interrupt to quit
06:49:38.629248 stat("/usr/local/nginx/html/www/index.html", 0x7fffbd4e7fc0) = -1 ENOENT (No such file or directory)
06:49:38.629329 stat("/usr/local/nginx/html/www", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
06:49:38.629353 stat("/usr/local/nginx/html/www/index.htm", 0x7fffbd4e7fc0) = -1 ENOENT (No such file or directory)
```

（4）跟踪系统调用统计

> strace不仅能够追踪系统调用，使用选项-c还能对进程所有的系统调用做一个统计分析

```
[root@localhost tmp]# strace -c /usr/local/nginx/sbin/nginx     #使用-c参数为进程所有的系统调用做一个统计分析
% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
100.00    0.000047          47         1           clone
  0.00    0.000000           0        29           read
  0.00    0.000000           0        31           open
  0.00    0.000000           0        33           close
  0.00    0.000000           0         6           stat
  0.00    0.000000           0        28           fstat
  0.00    0.000000           0         1           lseek
  0.00    0.000000           0        61           mmap
  0.00    0.000000           0        36           mprotect
  0.00    0.000000           0         7           munmap
  0.00    0.000000           0         6           brk
  0.00    0.000000           0        14           rt_sigaction
  0.00    0.000000           0         1           rt_sigprocmask
  0.00    0.000000           0         1           ioctl
  0.00    0.000000           0         2           pread
  0.00    0.000000           0         2         2 access
  0.00    0.000000           0         5           socket
  0.00    0.000000           0         4         4 connect
  0.00    0.000000           0         1           bind
  0.00    0.000000           0         2           listen
  0.00    0.000000           0         1           setsockopt
  0.00    0.000000           0         1           execve
  0.00    0.000000           0         2           uname
  0.00    0.000000           0         3           fcntl
  0.00    0.000000           0         5         5 mkdir
  0.00    0.000000           0         3           getrlimit
  0.00    0.000000           0         1           geteuid
  0.00    0.000000           0         1           statfs
  0.00    0.000000           0         1           arch_prctl
  0.00    0.000000           0         2         1 futex
  0.00    0.000000           0         1           epoll_create
  0.00    0.000000           0         1           set_tid_address
  0.00    0.000000           0         1           set_robust_list
------ ----------- ----------- --------- --------- ----------------
100.00    0.000047                   294        12 total
```

> 上面的结果将清楚地告诉我们调用了哪些系统函数，调用的次数是多少，消耗了多少时间等信息，这对我们分析程序来说是非常有用的。

（5）重定向输出

```
[root@localhost tmp]# strace -c -o /tmp/test.txt /usr/local/nginx/sbin/nginx #-o选项将strace的结果输出到文件中
[root@localhost tmp]# cat test.txt 
% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
  -nan    0.000000           0        29           read
  -nan    0.000000           0        31           open
  -nan    0.000000           0        33           close
  -nan    0.000000           0         6           stat
```

（6）对系统调用进行计时

```
[root@localhost tmp]# /usr/local/nginx/sbin/nginx -s stop
[root@localhost tmp]# strace -T /usr/local/nginx/sbin/nginx #使用-T将每个系统调用所花费的时间打印出来，每个调用的时间花销在调用行最右边的尖括号里
execve("/usr/local/nginx/sbin/nginx", ["/usr/local/nginx/sbin/nginx"], [/* 24 vars */]) = 0 <0.000075>
brk(0)                                  = 0x1055000 <0.000003>
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fbbf84f6000 <0.000004>
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory) <0.000005>
open("/etc/ld.so.cache", O_RDONLY)      = 3 <0.000004>
fstat(3, {st_mode=S_IFREG|0644, st_size=15441, ...}) = 0 <0.000003>
mmap(NULL, 15441, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fbbf84f2000 <0.000003>
close(3)                                = 0 <0.000003>
open("/lib64/libdl.so.2", O_RDONLY)     = 3 <0.000005>
read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\340\r\0\0\0\0\0\0"..., 832) = 832 <0.000003>
fstat(3, {st_mode=S_IFREG|0755, st_size=19536, ...}) = 0 <0.000003>
mmap(NULL, 2109696, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fbbf80d4000 <0.000004>
mprotect(0x7fbbf80d6000, 2097152, PROT_NONE) = 0 <0.000004>
......
```

#### 1.7.3 小结

> strace命令很适合处理程序僵尸、命令执行报错等问题。如果从程序日志和系统日志中看不出问题出现的原因，则可以strace一下，也许会有答案，不过也需要使用者有足够的耐心去查看输出。

### 1.8 ltrace :跟踪进程调用库函数

#### 1.8.1 命令解释

**功能说明：**

> ltrace能够跟踪进程的库函数调用，它会显现出调用了哪个库函数，而strace则是跟踪进程的每个系统调用

**选项说明：**

| 参数选项    | 解释说明（带@为重点）                                        |
| ----------- | ------------------------------------------------------------ |
| -c          | 统计库函数每次调用的时间，最后程序退出时打印摘要             |
| -C          | 解码低级别名称（内核级）为用户级名称                         |
| -d          | 打印调试信息                                                 |
| -e expr     | 输出过滤器，通过表达式，可以过滤掉你不想要的输出@            |
| -e printf   | 表示只查看printf函数调用                                     |
| -f          | 跟踪子进程                                                   |
| -o filename | 将ltrace的输出写入文件filename                               |
| -p pid      | 指定要跟踪的进程pid@                                         |
| -r          | 输出每一个调用的相对时间                                     |
| -S          | 显示系统调用                                                 |
| -t          | 在输出中每一行前加上时间信息。例如 16:45:28                  |
| -tt         | 在输出中每一行前加上时间信息。例如 11:18:59.759546           |
| -ttt        | 在输出中每一行前加上时间信息，精确到微妙，而且时间表示为UNIX时间戳。 |
| -T          | 显示每次调用所花费时间                                       |
| -u username | 以username的UID和GID执行所跟踪的命令                         |

#### 1.8.2 使用范例

（1）ltrace使用

> ltrace的用法与strace非常相似，选项功能也是类似，下面简单看一下ltrace命令的执行结果

```
[root@localhost tmp]# ltrace /usr/local/nginx/sbin/nginx    #ltrace后面直接接上要检测的命令语句
memcpy(0x1d5b7b0, "www.yunjisuan.com", 17)                              = 0x1d5b7b0
memcpy(0x1d5b7c1, "/usr/local/nginx/", 17)                              = 0x1d5b7c1
malloc(2048)                                                            = 0x1d55530
memset(0x1d55530, '\000', 68)                                           = 0x1d55530
memset(0x1d55530, '\000', 70)                                           = 0x1d55530
memset(0x1d55530, '\000', 72)                                           = 0x1d55530
memset(0x1d55530, '\000', 74)                                           = 0x1d55530
memset(0x1d55530, '\000', 76)                                           = 0x1d55530
memset(0x1d55530, '\000', 78)                                           = 0x1d55530
memset(0x1d55530, '\000', 80)                                           = 0x1d55530
memset(0x1d55530, '\000', 82)                                           = 0x1d55530
memset(0x1d55530, '\000', 84)                                           = 0x1d55530
memset(0x1d55530, '\000', 86)                                           = 0x1d55530
......
sigemptyset(0x7fffb75519f8)                                             = 0
sigaction(17, 0x7fffb75519f0, NULL)                                     = 0
sigemptyset(0x7fffb75519f8)                                             = 0
sigaction(31, 0x7fffb75519f0, NULL)                                     = 0
sigemptyset(0x7fffb75519f8)                                             = 0
sigaction(13, 0x7fffb75519f0, NULL)                                     = 0
fork()                                                                  = 3962
[pid 3961] exit(0 <unfinished ...>
[pid 3961] +++ exited (status 0) +++
```

（2）通过pid跟踪进程调用库函数

```
[root@localhost tmp]# pgrep -l nginx
3967 nginx
3968 nginx          #nginx的worker进程的pid号
[root@localhost tmp]# ltrace -p 3968        使用-p指定进程号
__errno_location()                                                      = 0x7f0a392e1768
gettimeofday(0x7fff8f684cd0, NULL)                                      = 0
memcpy(0x6b281f, "14", 2)                                               = 0x6b281f
memcpy(0x6b2826, "2018", 4)                                             = 0x6b2826
memcpy(0x6b282b, "12", 2)                                               = 0x6b282b
memcpy(0x6b282e, "28", 2)                                               = 0x6b282e
memcpy(0x6b2831, "30", 2)                                               = 0x6b2831
localtime_r(0x7fff8f684c88, 0x7fff8f684d20, 0x48400a, 12339, 0x7fff8f684b52) = 0x7fff8f684d20
memcpy(0x6b22fc, "2018", 4)                                             = 0x6b22fc
memcpy(0x6b2302, "1", 1)                                                = 0x6b2302
memcpy(0x6b2304, "14", 2)                                               = 0x6b2304
memcpy(0x6b2308, "7", 1)                                                = 0x6b2308
memcpy(0x6b230a, "28", 2)                                               = 0x6b230a
memcpy(0x6b230d, "30", 2)                                               = 0x6b230d
memcpy(0x6b2f91, "14", 2)                                               = 0x6b2f91
memcpy(0x6b2f98, "2018", 4)                                             = 0x6b2f98
memcpy(0x6b2f9e, "7", 1)                                                = 0x6b2f9e
memcpy(0x6b2fa0, "28", 2)                                               = 0x6b2fa0
memcpy(0x6b2fa3, "30", 2)                                               = 0x6b2fa3
memcpy(0x6b2fa8, "5", 1)                                                = 0x6b2fa8
memcpy(0x6b2faa, "0", 1)                                                = 0x6b2faa
memcpy(0x6b364e, "2018", 4)                                             = 0x6b364e
memcpy(0x6b3654, "1", 1)                                                = 0x6b3654
memcpy(0x6b3656, "14", 2)                                               = 0x6b3656
memcpy(0x6b365a, "7", 1)                                                = 0x6b365a
memcpy(0x6b365c, "28", 2)                                               = 0x6b365c
memcpy(0x6b365f, "30", 2)                                               = 0x6b365f
memcpy(0x6b3663, "5", 1)                                                = 0x6b3663
memcpy(0x6b3666, "0", 1)                                                = 0x6b3666
memcpy(0x6b3cb4, "14", 2)                                               = 0x6b3cb4
memcpy(0x6b3cb8, "7", 1)                                                = 0x6b3cb8
memcpy(0x6b3cba, "28", 2)                                               = 0x6b3cba
memcpy(0x6b3cbd, "30", 2)                                               = 0x6b3cbd
epoll_wait(8, 0x2639990, 512, 0xffffffff, 0x7fff8f684b52
```

## 二，Linux核心网络管理命令

### 2.1 ip:网络配置工具

#### 2.1.1 命令解释

**功能说明：**

> ip命令是iproute软件包中的一个强大的网络配置工具，用于显示或管理Linux系统的路由，网络设备，策略路由和隧道

**选项说明：**

| 参数选项 | 解释说明（带@的为重点）                                      |
| -------- | ------------------------------------------------------------ |
| -s       | 输出更详细的信息，为了相似更详细的信息，可重复使用此选项     |
| -r       | 显示主机时，不使用IP地址，而是使用主机的域名                 |
| 网络对象 | 指定要管理的网络对象（link：网络设备 address：IP地址 addrlabel：协议地址标签管理 route：路由表 rule：策略路由表 runnel：IP隧道 ） |
| help     | ip help：查看ip命令的帮助 ip【object】help：查看指定的网络对象的帮助 |
| 操作命令 | 对指定的网络对象完成的具体操作。通常，每一个具体操作的命令后面又有一组相关的命令选项。不同的操作对象所支持的操作命令也不同。下面按照操作的网络对象给出所支持的常见操作命令 |
|          | link对象支持的操作命令：set（修改设备属性），show（显示设备属性） |
|          | address对象支持的操作命令：add（添加协议地址），del（删除协议地址），flush（清除协议地址），show（查看协议地址） |
|          | addrlabel对象支持的操作命令：add，del，list，flush           |
|          | route对象支持的操作命令：add，change，replace，delete，show，flush，get |
|          | rule对象支持的操作命令：add，delete，flush，show             |
|          | tunnel对象支持的操作命令：add，change，delete，prl，show     |

#### 2.1.2 使用范例

（1）显示网络设备属性

```
[root@Mr_chen ~]# ip link show eth0 #显示eth1网卡属性
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:a8:ca:50 brd ff:ff:ff:ff:ff:ff
[root@Mr_chen ~]# ip -s link show eth0  #显示详细属性
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:a8:ca:50 brd ff:ff:ff:ff:ff:ff
    RX: bytes  packets  errors  dropped overrun mcast   #显示每个网络设备上数据包的统计信息
    37242      432      0       0       0       0      
    TX: bytes  packets  errors  dropped carrier collsns 
    22769      178      0       0       0       0      
[root@Mr_chen ~]# ip -s -s link show eth0   #使用两个-s显示更详细属性
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:a8:ca:50 brd ff:ff:ff:ff:ff:ff
    RX: bytes  packets  errors  dropped overrun mcast   
    44464      523      0       0       0       0      
    RX errors: length  crc     frame   fifo    missed
               0        0       0       0       0      
    TX: bytes  packets  errors  dropped carrier collsns 
    26699      209      0       0       0       0      
    TX errors: aborted fifo    window  heartbeat
               0        0       0       0      
```

（2）关闭和激活网络设备

```
[root@Mr_chen ~]# ip link show eth1
3: eth1: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN qlen 1000
    link/ether 00:0c:29:a8:ca:5a brd ff:ff:ff:ff:ff:ff
[root@Mr_chen ~]# ip link set eth1 up   #激活eth1网卡
[root@Mr_chen ~]# ip link show dev eth1
3: eth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:a8:ca:5a brd ff:ff:ff:ff:ff:ff
[root@Mr_chen ~]# ip link set eth1 down #关闭eth1网卡
[root@Mr_chen ~]# ip link show eth1
3: eth1: <BROADCAST,MULTICAST> mtu 1500 qdisc pfifo_fast state DOWN qlen 1000
    link/ether 00:0c:29:a8:ca:5a brd ff:ff:ff:ff:ff:ff
```

（3）修改网卡MAC地址

```
[root@Mr_chen ~]# ip link show eth1 
3: eth1: <BROADCAST,MULTICAST> mtu 1500 qdisc pfifo_fast state DOWN qlen 1000
    link/ether 00:0c:29:a8:ca:5a brd ff:ff:ff:ff:ff:ff
[root@Mr_chen ~]# ip link set eth1 address 0:0c:29:a8:ca:5f #修改MAC地址
[root@Mr_chen ~]# ip link show eth1
3: eth1: <BROADCAST,MULTICAST> mtu 1500 qdisc pfifo_fast state DOWN qlen 1000
    link/ether 00:0c:29:a8:ca:5f brd ff:ff:ff:ff:ff:ff
```

（4）查看网卡信息

```
[root@Mr_chen ~]# ip a  #效果与ip address一样，显示的结果包括激活和未激活的网卡
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 16436 qdisc noqueue state UNKNOWN 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:a8:ca:50 brd ff:ff:ff:ff:ff:ff
    inet 192.168.0.100/24 brd 192.168.0.255 scope global eth0
    inet6 fe80::20c:29ff:fea8:ca50/64 scope link 
       valid_lft forever preferred_lft forever
3: eth1: <BROADCAST,MULTICAST> mtu 1500 qdisc pfifo_fast state DOWN qlen 1000
    link/ether 00:0c:29:a8:ca:5f brd ff:ff:ff:ff:ff:ff
[root@Mr_chen ~]# ip link   #和ip a对比，少了具体的IP地址信息
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 16436 qdisc noqueue state UNKNOWN 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:a8:ca:50 brd ff:ff:ff:ff:ff:ff
3: eth1: <BROADCAST,MULTICAST> mtu 1500 qdisc pfifo_fast state DOWN qlen 1000
    link/ether 00:0c:29:a8:ca:5f brd ff:ff:ff:ff:ff:ff
```

（5）添加或删除IP地址

```
root@Mr_chen ~]# ip a show eth1 #显示eth1的IP地址，没有配置
3: eth1: <BROADCAST,MULTICAST> mtu 1500 qdisc pfifo_fast state DOWN qlen 1000
    link/ether 00:0c:29:a8:ca:5f brd ff:ff:ff:ff:ff:ff
[root@Mr_chen ~]# ip a add 192.168.0.222/24 dev eth1    #添加一个IP地址
[root@Mr_chen ~]# ip a show eth1    #虽然显示出了IP地址，但是网卡状态还是down
3: eth1: <BROADCAST,MULTICAST> mtu 1500 qdisc pfifo_fast state DOWN qlen 1000
    link/ether 00:0c:29:a8:ca:5f brd ff:ff:ff:ff:ff:ff
    inet 192.168.0.222/24 scope global eth1
[root@Mr_chen ~]# ip link set eth1 up   #激活网卡
[root@Mr_chen ~]# ip a show eth1    #现在eth1网卡正常运行
3: eth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:a8:ca:5f brd ff:ff:ff:ff:ff:ff
    inet 192.168.0.222/24 scope global eth1
    inet6 fe80::20c:29ff:fea8:ca5f/64 scope link 
       valid_lft forever preferred_lft forever
[root@Mr_chen ~]# ip a add 192.168.0.223/24 dev eth1    #可添加多个IP，这种IP称为辅助IP
[root@Mr_chen ~]# ip a show eth1
3: eth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:a8:ca:5f brd ff:ff:ff:ff:ff:ff
    inet 192.168.0.222/24 scope global eth1
    inet 192.168.0.223/24 scope global secondary eth1
    inet6 fe80::20c:29ff:fea8:ca5f/64 scope link 
       valid_lft forever preferred_lft forever
[root@Mr_chen ~]# ip a del 192.168.0.222/24 dev eth1    #删除主IP也就是第一个IP地址
[root@Mr_chen ~]# ip a show eth1    #所有IP都没有了
3: eth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:a8:ca:5f brd ff:ff:ff:ff:ff:ff
    inet6 fe80::20c:29ff:fea8:ca5f/64 scope link 
       valid_lft forever preferred_lft forever
[root@Mr_chen ~]# ip a add 192.168.0.222/24 dev eth1    #添加两个IP地址
[root@Mr_chen ~]# ip a add 192.168.0.223/24 dev eth1
[root@Mr_chen ~]# ip a del 192.168.0.223/24 dev eth1    #删除辅助IP
[root@Mr_chen ~]# ip a show eth1
3: eth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:a8:ca:5f brd ff:ff:ff:ff:ff:ff
    inet 192.168.0.222/24 scope global eth1     #主IP仍旧被保留了
    inet6 fe80::20c:29ff:fea8:ca5f/64 scope link 
       valid_lft forever preferred_lft forever
```

> **小结：**
>
> - [x] :删除网卡的主IP地址，同时会删除该网卡的所有IP地址
> - [x] :删除网卡的辅助IP地址，不会影响该网卡的其他IP地址。
>
> **思考**：
>  我们该如何用ip命令创建网卡的别名IP呢？

```
[root@Mr_chen ~]# ip a add 192.168.0.225/24 dev eth1 label eth1:1   #使用label选项创建别名IP
[root@Mr_chen ~]# ip a show eth1
3: eth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:a8:ca:5f brd ff:ff:ff:ff:ff:ff
    inet 192.168.0.222/24 scope global eth1 #eth1网卡的主IP
    inet 192.168.0.223/24 scope global secondary eth1   #eth1网卡的辅助IP
    inet 192.168.0.225/24 scope global secondary eth1:1 #eth1网卡的别名IP
    inet6 fe80::20c:29ff:fea8:ca5f/64 scope link 
       valid_lft forever preferred_lft forever
```

> **知识扩展：**
>  我们利用ifconfig命令只能查看到网卡的别名IP而看不到它的辅助IP

```
[root@Mr_chen ~]# ip a show eth1
3: eth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:a8:ca:5f brd ff:ff:ff:ff:ff:ff
    inet 192.168.0.222/24 scope global eth1
    inet 192.168.0.223/24 scope global secondary eth1   #辅助IP
    inet 192.168.0.225/24 scope global secondary eth1:1 #别名IP
    inet6 fe80::20c:29ff:fea8:ca5f/64 scope link 
       valid_lft forever preferred_lft forever
[root@Mr_chen ~]# ifconfig
eth0      Link encap:Ethernet  HWaddr 00:0C:29:A8:CA:50  
          inet addr:192.168.0.100  Bcast:192.168.0.255  Mask:255.255.255.0
          inet6 addr: fe80::20c:29ff:fea8:ca50/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:5857 errors:0 dropped:0 overruns:0 frame:0
          TX packets:1019 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:420049 (410.2 KiB)  TX bytes:119175 (116.3 KiB)

eth1      Link encap:Ethernet  HWaddr 00:0C:29:A8:CA:5F  
          inet addr:192.168.0.222  Bcast:0.0.0.0  Mask:255.255.255.0
          inet6 addr: fe80::20c:29ff:fea8:ca5f/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:32 errors:0 dropped:0 overruns:0 frame:0
          TX packets:12 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:4212 (4.1 KiB)  TX bytes:936 (936.0 b)

eth1:1    Link encap:Ethernet  HWaddr 00:0C:29:A8:CA:5F     #别名IP
          inet addr:192.168.0.225  Bcast:0.0.0.0  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
```

（6）查看路由表

```
[root@Mr_chen ~]# ip route
192.168.0.0/24 dev eth0  proto kernel  scope link  src 192.168.0.100 
192.168.0.0/24 dev eth1  proto kernel  scope link  src 192.168.0.222 
169.254.0.0/16 dev eth0  scope link  metric 1002 
default via 192.168.0.1 dev eth0 
[root@Mr_chen ~]# ip route | column -t  #使用column命令格式化，选项-t，默认根据空格分隔判断输入行的列数来创建一个表
192.168.0.0/24  dev  eth0         proto  kernel  scope   link  src  192.168.0.100
192.168.0.0/24  dev  eth1         proto  kernel  scope   link  src  192.168.0.222
169.254.0.0/16  dev  eth0         scope  link    metric  1002
default         via  192.168.0.1  dev    eth0
[root@Mr_chen ~]# route -n  #与我们前面学习过的route命令对比一下
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
192.168.0.0     0.0.0.0         255.255.255.0   U     0      0        0 eth0
192.168.0.0     0.0.0.0         255.255.255.0   U     0      0        0 eth1
169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0
0.0.0.0         192.168.0.1     0.0.0.0         UG    0      0        0 eth0
```

（7）添加或删除路由表

```
[root@Mr_chen ~]# ip route add 192.168.1.0/24 via 192.168.0.254 dev eth1    #添加静态路由
[root@Mr_chen ~]# ip route | column -t
192.168.1.0/24  via  192.168.0.254  dev    eth1
192.168.0.0/24  dev  eth0           proto  kernel  scope   link  src  192.168.0.100
192.168.0.0/24  dev  eth1           proto  kernel  scope   link  src  192.168.0.222
169.254.0.0/16  dev  eth0           scope  link    metric  1002
default         via  192.168.0.1    dev    eth0
[root@Mr_chen ~]# route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
192.168.1.0     192.168.0.254   255.255.255.0   UG    0      0        0 eth1
192.168.0.0     0.0.0.0         255.255.255.0   U     0      0        0 eth0
192.168.0.0     0.0.0.0         255.255.255.0   U     0      0        0 eth1
169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0
0.0.0.0         192.168.0.1     0.0.0.0         UG    0      0        0 eth0
[root@Mr_chen ~]# ip route del 192.168.1.0/24   #删除静态路由
[root@Mr_chen ~]# ip route | column -t
192.168.0.0/24  dev  eth0         proto  kernel  scope   link  src  192.168.0.100
192.168.0.0/24  dev  eth1         proto  kernel  scope   link  src  192.168.0.222
169.254.0.0/16  dev  eth0         scope  link    metric  1002
default         via  192.168.0.1  dev    eth0
```

### 2.2 netstat：查看网络状态

#### 2.2.1 命令详解

**功能说明：**

> netstat命令用于显示本机网络的连接状态，运行端口和路由表等信息。

**选项说明：**

| 参数选项 | 解释说明（带@的为重点）                                      |
| -------- | ------------------------------------------------------------ |
| -r       | 显示路由表信息，该功能类似与前面学过的route和ip route        |
| -g       | 显示多播功能群组成员，该功能类似于前面学过的ip maddr         |
| -i       | 显示网络接口信息，该功能类似于前面学过的ip -s link           |
| -s       | 显示各类协议的统计信息                                       |
| -n       | 显示数字形式的地址而不是去解析主机，端口或用户名。默认情况下，netstat命令会尝试解析并显示主机的主机名，这个过程通常比较长也是非必需的@ |
| -a       | 显示处于监听状态和非监听状态的socket信息@                    |
| -A       | 显示指定网络类型的网络连接状态                               |
| -c<秒数> | 后面跟的秒数表示每隔几秒就刷新显示一次@                      |
| -l       | 仅显示连接状态为“LISTEN”的服务的网络状态                     |
| -t       | 显示所有的TCP连接情况@                                       |
| -u       | 显示所有的UDP连接情况@                                       |
| -p       | 显示socket所属进程的PID和名称@                               |

#### 2.2.2 使用范例

##### 基础范例

（1）常用选项组合一

```
[root@localhost ~]# netstat -an
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address               Foreign Address             State      
tcp        0      0 0.0.0.0:22                  0.0.0.0:*                   LISTEN      
tcp        0     64 192.168.0.233:22            192.168.0.253:54737         ESTABLISHED 
tcp        0      0 :::22                       :::*                        LISTEN      
Active UNIX domain sockets (servers and established)
Proto RefCnt Flags       Type       State         I-Node Path
unix  2      [ ACC ]     STREAM     LISTENING     7510   @/com/ubuntu/upstart
unix  2      [ ]         DGRAM                    7857   @/org/kernel/udev/udevd
unix  4      [ ]         DGRAM                    8910   /dev/log
unix  2      [ ]         DGRAM                    9187   
unix  2      [ ]         DGRAM                    8976   
unix  3      [ ]         DGRAM                    7874   
unix  3      [ ]         DGRAM                    7873   
```

**第一行活动网络连接说明：**

| 列数   | 名称            | 含义                                                         |
| ------ | --------------- | ------------------------------------------------------------ |
| 第一列 | Proto           | socket使用的协议（TCP，UDP，RAW）                            |
| 第二列 | Recv-Q          | 接收到但是还未处理的字节数                                   |
| 第三列 | Send-Q          | 已经发送但是未被远程主机确认收到的字节数                     |
| 第四列 | Local Address   | 本地主机地址和端口                                           |
| 第五列 | Foreign Address | 远程主机地址和端口                                           |
| 第六列 | State           | socket的状态，通常仅仅有TCP的状态，状态值可能有ESTABLISHED，SYN_SENT,SYN_RECV,FIN_WAIT1,FIN_WAIT2,TIME_WAIT等 |

**第6列State状态信息详解**

| 状态        | 含义                                                         |
| ----------- | ------------------------------------------------------------ |
| ESTABLISHED | socket已经建立连接，表示处于连接的状态，一般认为有一个ESTABLISHED是一个服务的并发连接。该连接状态在生产场景中很重要，需要重点关注 |
| SYN_SENT    | socket正在积极尝试建立一个连接，即处于发送后连接前的一个等待但未匹配进入连接的状态 |
| SYN_RECV    | 已经从网络上收到一个连接请求                                 |
| FIN_WAIT1   | socket已关闭，连接正在或正要关闭                             |
| FIN_WAIT2   | 连接已关闭，并且socket正在等待远端结束                       |
| TIME_WAIT   | socket正在等待关闭处理仍在网络上的数据包，这个连接状态在生产场景中很重要，需要重点关注 |
| CLOSED      | socket不再被占用了                                           |
| CLOSE_WAIT  | 远端已经结束，等待socket关闭                                 |
| LAST_ACK    | 远端已经结束，并且socket也已经关闭，等待acknowledgement      |
| LISTEN      | socket正在监听连接请求                                       |
| CLOSING     | socket关闭，但是我们仍旧没有发送数据                         |
| UNKNOWN     | socket状态未知                                               |

（2）常用选项组合二

```
[root@localhost ~]# netstat -lntup
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address               Foreign Address             State       PID/Program name   
tcp        0      0 0.0.0.0:22                  0.0.0.0:*                   LISTEN      879/sshd            
tcp        0     64 192.168.0.233:22            192.168.0.253:54737         ESTABLISHED 923/sshd            
tcp        0      0 :::22                       :::*                        LISTEN      879/sshd 
```

> 以上命令语句的作用为显示所有TCP和UDP正在监听的连接信息
>
> - [x] -l : 显示所有LISTEN状态的网络连接
> - [x] -n : 显示IP地址，不进行DNS解析成主机名，域名
> - [x] -t : 显示所有TCP连接
> - [x] -u : 显示所有UDP连接
> - [x] -p : 显示进程号和进程名

（3）显示当前系统的路由表

```
[root@localhost ~]# netstat -rn #使用-r显示路由表信息，-n不进行DNS解析，加快命令执行速度
Kernel IP routing table
Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
192.168.0.0     0.0.0.0         255.255.255.0   U         0 0          0 eth0
169.254.0.0     0.0.0.0         255.255.0.0     U         0 0          0 eth0
0.0.0.0         192.168.0.1     0.0.0.0         UG        0 0          0 eth0

提示：该命令相当于route -n
```

（4）选项-i显示网络的接口状况

```
[root@localhost ~]# netstat -i
Kernel Interface table
Iface       MTU Met    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg
eth0       1500   0     4103      0      0      0      403      0      0      0 BMRU
lo        16436   0        0      0      0      0        0      0      0      0 LRU
```

> **以下是命令结果解释**
>
> - [x] Iface : 表示网络设备的接口名称
> - [x] MTU : 表示最大传输单元，单位为字节
> - [x] RX-OK/TX-OK : 表示已经准确无误地接收/发送了多少数据包
> - [x] RX-ERR/TX-ERR : 表示接收/发送数据包时产生了多少错误
> - [x] RX-DRP/TX-DRP : 表示接收/发送数据包时丢弃了多少数据包
> - [x] RX-OVR/TX-OVR : 表示由于误差而遗失了多少数据包。
> - [x] Flg : 表示接口标记，其中各标记含义具体如下。
>   - L : 表示该接口是个回环设备。
>   - B : 表示设置了广播地址。
>   - M : 表示接收所有数据包。
>   - R : 表示接口正在运行。
>   - U : 表示接口处于活动状态。
>   - O : 表示在该接口上禁用arp。
>   - P : 表示一个点到点的连接
>
> 正常情况下，RX-ERR/TX-ERR，RX-DRP/TX-DRP和RX-OVR/TX-OVR的值都应该为0，如果这几个选项的值不为0，并且很大，那么网络质量肯定有问题，网络传输性能也一定会下降。

##### 生产案例

（5）统计各个状态的网络连接个数

```
[root@Mr_chen ~]# 
TIME_WAIT 6163
FIN_WAIT1 42
FIN_WAIT2 

netstat -n | awk '/^tcp/{Mr_chen[$NF]++}END{for(i in Mr_chen)print i,Mr_chen[i]}'

1056
ESTABLISHED 4542
SYN_RECV 53
LAST_ACK 30
```

### 2.3 ss : 查看网络状态

#### 2.3.1 命令详解

**功能说明：**

> - ss命令是类似并将取代netstat的工具，它能用来查看网络状态信息，包括TCP，UDP连接，端口等。它的优点是能够显示更多更详细的有关网络连接状态的信息，而且比netstat更快速更高效。
> - 如果系统没有ss命令，那就需要安装一下，ss命令属于iproute包，因此安装命令是yum -y install iproute

**选项说明：**

| 参数选项 | 解释说明（带@的为重点）    | 参数选项 | 解释说明（带@的为重点） |
| -------- | -------------------------- | -------- | ----------------------- |
| -n       | 显示IP地址，不进行DNS解析@ | -s       | 显示socket使用统计      |
| -r       | 尝试解析数字IP地址和端口   | -4       | 仅显示IPV4的socket      |
| -a       | 显示所有socket连接@        | -6       | 仅显示IPv6的socket      |
| -l       | 显示所有监听socket@        | -0       | 仅显示PACKET的socket    |
| -o       | 显示计时器信息             | -t       | 仅显示TCP的socket@      |
| -e       | 显示详细的socket信息       | -u       | 仅显示UDP的socket@      |
| -m       | 显示socket的内存使用情况   | -d       | 仅显示DCCP的socket      |
| -p       | 显示使用socket的进程@      | -w       | 仅显示RAW的socket       |
| -i       | 显示TCP内部信息            | -x       | 仅显示Unix的socket      |

#### 2.3.2 使用范例

（1）常用选项组合一

```
[root@Mr_chen ~]# ss -an    #显示所有的socket连接
State       Recv-Q Send-Q                        Local Address:Port                          Peer Address:Port 
LISTEN      0      128                                      :::22                                      :::*     
LISTEN      0      128                                       *:22                                       *:*     
ESTAB       0      64                            192.168.0.233:22                           192.168.0.253:50985 
[root@Mr_chen ~]# ss -an | column -t    #上面的输出写在文档中会有点乱，下面用column格式化一下。
State   Recv-Q  Send-Q  Local             Address:Port         Peer  Address:Port
LISTEN  0       128     :::22             :::*
LISTEN  0       128     *:22              *:*
ESTAB   0       64      192.168.0.233:22  192.168.0.253:50985
```

（2）常用选项组合二

```
[root@Mr_chen ~]# ss -lntup | column -t #显示所有正在监听的TCP和UDP连接
Netid  State   Recv-Q  Send-Q  Local  Address:Port  Peer                    Address:Port
tcp    LISTEN  0       128     :::22  :::*          users:(("sshd",879,4))
tcp    LISTEN  0       128     *:22   *:*           users:(("sshd",879,3))
```

（3）显示socket统计

```
[root@Mr_chen ~]# ss -s #统计当前的established，closed，orphaned和waiting的TCP socket数量
Total: 282 (kernel 285)
TCP:   3 (estab 1, closed 0, orphaned 0, synrecv 0, timewait 0/0), ports 1

Transport Total     IP        IPv6
*     285       -         -        
RAW   0         0         0        
UDP   0         0         0        
TCP   3         2         1        
INET      3         2         1        
FRAG      0         0         0     
```

> 当服务器产生大量的socket连接时，通常会使用该命令来做宏观数据统计；ss的大部分参数应用和netstat很像。

### 2.4 ping ： 测试主机之间的网络连通性

#### 2.4.1 命令详解

**功能说明：**

> ping命令可用于测试主机之间网络的连通性。执行ping命令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而可得知该主机运作正常。

**选项说明：**

| 参数选项        | 解释说明（带@的为重点）                                      |
| --------------- | ------------------------------------------------------------ |
| -c <次数>       | 指定发送ICMP报文的次数。否则，ping命令将一直发送报文@        |
| -i <时间间隔>   | 相邻两次发送报文的时间间隔，默认时间间隔1s@                  |
| -n              | 不查询主机名，直接显示其IP地址                               |
| -q              | 只显示命令开始时的信息和运行结束的统计信息。忽略命令运行过程中的输出信息 |
| -s <数据包大小> | 设置发送数据包的大小，默认大小为56字节，再加上8字节的ICMP头，一共是64字节的ICMP包 |
| -t <生存期>     | 设置发送的数据包其生存期（TTL）的值                          |
| -w 截止时间     | 超过截止时间，立即退出ping程序                               |
| -W 超时时间     | 等待响应的超时时间                                           |

#### 2.4.2 使用范例

（1）测试到目标主机的网络连通性

```
[root@localhost ~]# ping www.baidu.com  #ping命令直接接域名或IP，会一直显示ping结果
PING www.a.shifen.com (61.135.169.121) 56(84) bytes of data.
#显示ping的域名及其IP地址，发送的是56字节的数据
64 bytes from 61.135.169.121: icmp_seq=1 ttl=57 time=10.1 ms
#从目标主机收到的数据是64字节，icmp_seq是收到包的序列号，ttl是数据包的生存期，time是延迟。
64 bytes from 61.135.169.121: icmp_seq=2 ttl=57 time=46.4 ms
64 bytes from 61.135.169.121: icmp_seq=3 ttl=57 time=62.5 ms
^C  #直到Ctrl+c强制终止
--- www.a.shifen.com ping statistics ---    #这里是ping的统计结果
3 packets transmitted, 3 received, 0% packet loss, time 2632ms  #发了3个包，收到3个，丢失率0%，时间为2632ms
rtt min/avg/max/mdev = 10.175/39.730/62.569/21.911 ms
#rtt是传输的时间延迟。min/avg/max/mdev==>最小/平均/最大/算数平均差
```

**扩展知识:**

> 1）ping命令会显示一个时间作为衡量网络参数延迟的参数，以判断源主机与目标主机之间网络的质量。
>  2）ping命令的输出信息中含有TTL值。TTL（Time To  Life）称为生存周期，它是ICMP报文在网络上的存活时间。不同的操作系统发出的ICMP报文的生存期各不相同，常见的生存期为32，64，128和255等。TTL值反映了ICMP报文所能够经过的路由器数目，每经过一个路由器，路由器都会将其数据包的生存期减去1，如果TTL值变为0，则路由器将不再转发此报文。

（2）使用ping参数的不同组合的例子

```
[root@Mr_chen ~]# ping -c 3 -i 3 -s 1024 -t 255 www.baidu.com
PING www.baidu.com (61.135.169.121) 1024(1052) bytes of data.
1032 bytes from 61.135.169.121: icmp_seq=1 ttl=57 time=5.29 ms
1032 bytes from 61.135.169.121: icmp_seq=2 ttl=57 time=4.79 ms
1032 bytes from 61.135.169.121: icmp_seq=3 ttl=57 time=5.50 ms

--- www.baidu.com ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 6014ms
rtt min/avg/max/mdev = 4.795/5.198/5.507/0.304 ms
```

> 以下是命令说明
>
> - [x] -c 3:发送3次ICMP包
> - [x] -i 3:每次发包时间间隔为3s
> - [x] -s 1024:设置发送的数据包大小为1024字节
> - [x] -t 255:设置发送数据包的ttl值为255

### 2.5 nmap：网络探测工具和安全/端口扫描器

#### 2.5.1 命令详解

**功能说明：**

> nmap命令是一款开放源代码的网络探测和安全审核工具，是Network Mapper的缩写。其设计目标是快速地扫描大型网络。nmap可以发现网络上有哪些主机，主机提供了什么服务（应用程序名称和版本号），并探测操作系统的类型及版本信息。
>  如果系统没有nmap命令，则可以使用下面的命令来安装：
>  `yum -y install nmap`

**选项说明：**

| 参数选项     | 解释说明（带@的为重点）                                      |
| ------------ | ------------------------------------------------------------ |
| -sS          | TCP同步扫描（TCP SYN）@                                      |
| -sT          | TCP连接扫描                                                  |
| -sn          | 不进行端口扫描，只检查主机正在运行。该选项与老版本的-sP相同@ |
| -sU          | 扫描UDP端口                                                  |
| -sV          | 探测服务版本信息                                             |
| -Pn          | 只进行扫描，不ping主机                                       |
| -PS          | 使用SYN包对目标主机进行扫描。默认是80端口，也可以指定端口，格式为-PS22或-PS22-25，80，113，1050，35000，记住PS和端口号之间不要有空格 |
| -PU          | 使用udp ping扫描端口                                         |
| -O           | 激活对TCP/IP指纹特征（fingerprinting）的扫描，获得远程主机的标志，也就是操作系统类型 |
| -v           | 显示扫描过程中的详细信息@                                    |
| -S           | 设置扫描的源IP地址                                           |
| -g port      | 设置扫描的源端口                                             |
| -oN          | 把扫描的结果重定向到文件中                                   |
| -iL filename | 从文件中读取扫描的目标                                       |
| -p <端口>    | 指定要扫描的端口，可以是一个单独的端口，也可以用逗号分隔开多个端口，或者使用“-”表示端口范围@ |
| -n           | 不进行DNS解析，加快扫描速度@                                 |
| -exclude     | 排除指定主机                                                 |
| -excludefile | 排除指定文件中的主机                                         |

#### 2.5.2 使用范例

（1）查看主机当前开放的端口

```
[root@Mr_chen ~]# nmap 192.168.0.1  #直接接目标主机，默认会扫描1~1000端口

Starting Nmap 5.51 ( http://nmap.org ) at 2018-02-28 08:23 EST
Nmap scan report for localhost (192.168.0.1)
Host is up (0.014s latency).        #目标主机正在运行
Not shown: 999 closed ports         #999个端口关闭
PORT   STATE SERVICE
80/tcp open  http                   #开放的80端口http服务
MAC Address: CC:B2:55:DF:3C:83 (Unknown)

Nmap done: 1 IP address (1 host up) scanned in 0.37 seconds
```

（2）扫描主机的指定端口

```
[root@Mr_chen ~]# nmap -p 1024-65535 192.168.0.1    #-p选项指定扫描范围

Starting Nmap 5.51 ( http://nmap.org ) at 2018-02-28 08:26 EST
Nmap scan report for localhost (192.168.0.1)
Host is up (0.039s latency).
Not shown: 64511 closed ports
PORT     STATE SERVICE
1780/tcp open  unknown
MAC Address: CC:B2:55:DF:3C:83 (Unknown)

Nmap done: 1 IP address (1 host up) scanned in 17.46 seconds
```

（3）扫描局域网内所有的IP

```
[root@Mr_chen ~]# nmap 192.168.0.0/24   #使用网段的格式扫描局域网

Starting Nmap 5.51 ( http://nmap.org ) at 2018-02-28 08:29 EST
Nmap scan report for localhost (192.168.0.1)
Host is up (0.0072s latency).
Not shown: 999 closed ports
PORT   STATE SERVICE
80/tcp open  http
MAC Address: CC:B2:55:DF:3C:83 (Unknown)

Nmap scan report for localhost (192.168.0.129)
Host is up (0.092s latency).
Not shown: 999 closed ports
PORT   STATE SERVICE
80/tcp open  http
MAC Address: F0:FE:6B:69:5B:1E (Unknown)

Nmap scan report for localhost (192.168.0.133)
Host is up (0.33s latency).
All 1000 scanned ports on localhost (192.168.0.133) are closed
MAC Address: BC:3D:85:FE:3F:DA (Unknown)

Nmap scan report for localhost (192.168.0.233)
Host is up (0.0000010s latency).
Not shown: 999 closed ports
PORT   STATE SERVICE
22/tcp open  ssh

Nmap scan report for localhost (192.168.0.254)
Host is up (0.00016s latency).
Not shown: 992 closed ports
PORT      STATE SERVICE
135/tcp   open  msrpc
139/tcp   open  netbios-ssn
443/tcp   open  https
445/tcp   open  microsoft-ds
902/tcp   open  iss-realsecure
912/tcp   open  apex-mesh
5678/tcp  open  rrac
10000/tcp open  snet-sensor-mgmt
MAC Address: 30:B4:9E:74:1B:3B (Unknown)

Nmap done: 256 IP addresses (5 hosts up) scanned in 19.27 seconds

[root@Mr_chen ~]# nmap -sn 192.168.0.0/24   #使用-sn选项不扫描端口

Starting Nmap 5.51 ( http://nmap.org ) at 2018-02-28 08:32 EST
Nmap scan report for localhost (192.168.0.1)
Host is up (0.0027s latency).
MAC Address: CC:B2:55:DF:3C:83 (Unknown)
Nmap scan report for localhost (192.168.0.233)
Host is up.
Nmap scan report for localhost (192.168.0.254)
Host is up (0.000071s latency).
MAC Address: 30:B4:9E:74:1B:3B (Unknown)
Nmap done: 256 IP addresses (3 hosts up) scanned in 2.56 seconds

[root@Mr_chen ~]# nmap -sn 192.168.0.232-234    #使用这种地址范围进行扫描

Starting Nmap 5.51 ( http://nmap.org ) at 2018-02-28 08:34 EST
Nmap scan report for localhost (192.168.0.233)
Host is up.
Nmap done: 3 IP addresses (1 host up) scanned in 0.81 seconds
```

（4）探测目标主机的服务和操作系统的版本

```
[root@Mr_chen ~]# nmap -O -sV 192.168.0.1

Starting Nmap 5.51 ( http://nmap.org ) at 2018-02-28 08:43 EST
Nmap scan report for localhost (192.168.0.1)
Host is up (0.0037s latency).
Not shown: 999 closed ports
PORT   STATE SERVICE VERSION
80/tcp open  http    Linksys wireless-G WAP http config (Name D-Link Wireless N Router DIR-600M)
MAC Address: CC:B2:55:DF:3C:83 (Unknown)
Device type: general purpose
Running: Linux 2.4.X
OS details: Linux 2.4.18 - 2.4.35 (likely embedded)
Network Distance: 1 hop
Service Info: Device: WAP

OS and Service detection performed. Please report any incorrect results at http://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 2.93 seconds
```

> 上边的输出信息中不仅包含了端口号，而且还包括了服务的版本号。在网络安全性要求较高的主机上，最好能够屏蔽服务版本号，以防止黑客利用特定版本的服务漏洞进行攻击。

### 2.6 tcpdump：监听网络流量

#### 2.6.1 命令详解

**功能说明：**

> - tcpdump命令是一个截获网络数据包的包分析工具。tcpdump可以将网络中传送的数据包的“头”完全截获下来以提供分析。它支持针对网络层，协议，主机，端口等的过滤，并支持与，或，非逻辑语句协助过滤有效信息。
> - tcpdump命令工作时要先把网卡的工作模式切换到混杂模式（promiscuous mode）。因为要修改网络接口的工作模式，所以tcpdump命令需要以root的身份运行。

**选项说明：**

| 参数选项        | 解释说明（带@的为重点）                                      |
| --------------- | ------------------------------------------------------------ |
| -A              | 以ASCII码的方式显示每一个数据包（不会显示数据包中链路层的头部信息）。在抓取包含网页数据的数据包时，可方便查看数据 |
| -c <数据包数目> | 接收到指定的数据包数目后退出命令@                            |
| -e              | 每行的打印输出中将包含数据包的数据链路层头部信息             |
| -i <网络接口>   | 指定要监听数据包的网络接口@                                  |
| -n              | 不进行DNS解析，加快显示速度@                                 |
| -nn             | 不将协议和端口数字等转换成名字@                              |
| -q              | 以快速输出的方式运行，此选项仅显示数据包的协议概要信息，输出信息较短@ |
| -s <数据包大小> | 设置数据包抓取长度，如果不设置则默认为68字节，设置为0则自动选择合适的长度来抓取数据包 |
| -t              | 在每行输出信息中不显示时间戳标记                             |
| -tt             | 在每行输出信息中显示无格式的时间戳标记                       |
| -ttt            | 显示当前行与前一行的延迟                                     |
| -tttt           | 在每行打印的时间戳之前添加日期                               |
| -ttttt          | 显示当前行与第一行的延迟                                     |
| -v              | 显示命令执行的详细信息                                       |
| -vv             | 显示比-v选项更加详细的信息                                   |
| -vvv            | 显示比-vv选项更加详细的输出                                  |

#### 2.6.2 使用范例

（1）不加参数运行tcpdump命令监听网络

```
[root@localhost ~]# tcpdump #默认情况下，直接启动tcpdump将监视第一个网络接口上所有流过的数据包
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes
05:12:45.464963 IP localhost.ssh > localhost.50832: Flags [P.], seq 898292388:898292596, ack 861396487, win 317, length 208
05:12:45.465055 IP localhost.50832 > localhost.ssh: Flags [.], ack 208, win 523, length 0
05:12:45.465215 IP localhost.57595 > localhost.domain: 4104+ PTR? 254.0.168.192.in-addr.arpa. (44)
05:12:45.467851 IP localhost.domain > localhost.57595: 4104 1/0/0 PTR localhost. (67)
05:12:45.467906 IP localhost.57067 > localhost.domain: 107+ PTR? 233.0.168.192.in-addr.arpa. (44)
05:12:45.469444 IP localhost.domain > localhost.57067: 107 1/0/0 PTR localhost. (67)
05:12:45.469504 IP localhost.34192 > localhost.domain: 2703+ PTR? 1.0.168.192.in-addr.arpa. (42)
05:12:45.621206 IP localhost.ssh > localhost.50832: Flags [P.], seq 3120:3280, ack 1, win 317, length 160
05:12:45.621258 IP localhost.50832 > localhost.ssh: Flags [.], ack 3280, win 524, length 0
05:12:45.636742 IP localhost.ssh > localhost.50832: Flags [P.], seq 3280:3536, ack 1, win 317, length 256
05:12:45.643843 IP localhost.50832 > localhost.ssh: Flags [P.], seq 1:65, ack 3536, win 523, length 64
05:12:45.643889 IP localhost.ssh > localhost.50832: Flags [P.], seq 3536:3696, ack 65, win 317, length 160
^C              #tcpdump命令在运行期间可以使用组合Ctrl+C终止程序
29 packets captured     #最后三行就是按CTRL+C后输出的监听到的数据包汇总信息
32 packets received by filter
0 packets dropped by kernel
```

> 使用tcpdump命令时，如果不输入过滤规则，则输出的数据量将会很大。

（2）精简输出信息

```
[root@localhost ~]# tcpdump -q  #默认情况下，tcpdump命令的输出信息较多，为了显示精简的信息，可以使用-q选项
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes
05:33:01.438200 IP localhost.ssh > localhost.50832: tcp 208
05:33:01.479036 IP localhost.50832 > localhost.ssh: tcp 0
05:33:01.494539 IP localhost.ssh > localhost.50832: tcp 176
05:33:01.510460 IP localhost.ssh > localhost.50832: tcp 112
05:33:01.510907 IP localhost.50832 > localhost.ssh: tcp 0
05:33:01.525789 IP localhost.ssh > localhost.50832: tcp 176
05:33:01.541450 IP localhost.ssh > localhost.50832: tcp 112
05:33:01.541548 IP localhost.50832 > localhost.ssh: tcp 0
05:33:01.557049 IP localhost.ssh > localhost.50832: tcp 176
05:33:01.574173 IP localhost.ssh > localhost.50832: tcp 112
05:33:01.574486 IP localhost.50832 > localhost.ssh: tcp 0
05:33:01.583765 IP localhost.50832 > localhost.ssh: tcp 64
05:33:01.583857 IP localhost.ssh > localhost.50832: tcp 176
^C
24 packets captured
26 packets received by filter
0 packets dropped by kernel
[root@localhost ~]# tcpdump -c 5    #使用-c选项指定监听的数据包数量，这样就不需要使用Ctrl+C了
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes
05:34:24.515192 IP localhost.ssh > localhost.50832: Flags [P.], seq 898300004:898300212, ack 861398503, win 317, length 208
05:34:24.515301 IP localhost.50832 > localhost.ssh: Flags [.], ack 208, win 519, length 0
05:34:24.515445 IP localhost.60389 > localhost.domain: 26412+ PTR? 254.0.168.192.in-addr.arpa. (44)
05:34:24.518180 IP localhost.domain > localhost.60389: 26412 1/0/0 PTR localhost. (67)
05:34:24.518247 IP localhost.38804 > localhost.domain: 7473+ PTR? 233.0.168.192.in-addr.arpa. (44)
5 packets captured
10 packets received by filter
0 packets dropped by kernel
```

（3）监听指定网卡收到的数据包

```
[root@Mr_chen ~]# tcpdump -i eth0   #使用-i选项可以指定要监听的网卡
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes
05:46:06.865643 IP localhost.ssh > localhost.50832: Flags [P.], seq 898335828:898336036, ack 861403175, win 317, length 208
05:46:06.865721 IP localhost.50832 > localhost.ssh: Flags [.], ack 208, win 524, length 0
05:46:06.865876 IP localhost.37090 > localhost.domain: 16313+ PTR? 254.0.168.192.in-addr.arpa. (44)
^C
49 packets captured
52 packets received by filter
0 packets dropped by kernel
```

> 以下是命令的结果说明
>
> - [x] 05:46:06.865643:当前时间，精确到微妙
> - [x] IP localhost.ssh > localhost.50832:从主机localhost的SSH端口发送数据到localhost的50832端口，“>”代表数据流向
> - [x] Flags [P.]:TCP包中的标志信息，S是SYN标志的缩写，F（FIN），P（PUSH），R（RST），“.”（没有标记）。
> - [x] seq:数据包中的数据的顺序号。
> - [x] ack:下次期望的顺序号
> - [x] win:接收缓存的窗口大小
> - [x] length:数据包长度

（4）监听指定主机的数据包

```
[root@Mr_chen ~]# tcpdump -n -c 5 host 192.168.0.254    #使用-n选项不进行DNS解析，加快显示速度。监听指定主机的关键字为host，后面直接接主机名或IP地址即可。本行命令的作用是监听所有192.168.0.254的主机收到的和发出的数据包
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes
06:18:59.812585 IP 192.168.0.233.ssh > 192.168.0.254.50832: Flags [P.], seq 898389300:898389508, ack 861410071, win 317, length 208
06:18:59.812763 IP 192.168.0.254.50832 > 192.168.0.233.ssh: Flags [.], ack 208, win 524, length 0
06:18:59.813478 IP 192.168.0.233.ssh > 192.168.0.254.50832: Flags [P.], seq 208:496, ack 1, win 317, length 288
06:18:59.814441 IP 192.168.0.233.ssh > 192.168.0.254.50832: Flags [P.], seq 496:672, ack 1, win 317, length 176
06:18:59.814534 IP 192.168.0.254.50832 > 192.168.0.233.ssh: Flags [.], ack 672, win 522, length 0
5 packets captured
5 packets received by filter
0 packets dropped by kernel
[root@Mr_chen ~]# tcpdump -n -c 5 src host 192.168.0.254    #只监听从192.168.0.254发出的数据包，即源地址为192.168.0.254,关键字为src（source，源地址）
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes
06:19:45.439633 IP 192.168.0.254.50832 > 192.168.0.233.ssh: Flags [.], ack 898393156, win 522, length 0
06:19:45.511489 IP 192.168.0.254.50832 > 192.168.0.233.ssh: Flags [.], ack 161, win 521, length 0
06:19:45.589521 IP 192.168.0.254.50832 > 192.168.0.233.ssh: Flags [.], ack 321, win 520, length 0
06:19:45.667712 IP 192.168.0.254.50832 > 192.168.0.233.ssh: Flags [.], ack 481, win 520, length 0
06:19:45.733979 IP 192.168.0.254.50832 > 192.168.0.233.ssh: Flags [.], ack 641, win 519, length 0
5 packets captured
6 packets received by filter
0 packets dropped by kernel
[root@Mr_chen ~]# tcpdump -n -c 5 dst host 192.168.0.254    #只监听192.168.0.254收到的数据包，即目标地址为192.168.0.254，关键字为dst（destination，目的地）
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes
18:21:33.783811 IP 192.168.0.233.ssh > 192.168.0.254.55962: Flags [P.], seq 1885784800:1885785008, ack 322191067, win 317, length 208
18:21:33.785709 IP 192.168.0.233.ssh > 192.168.0.254.55962: Flags [P.], seq 208:400, ack 1, win 317, length 192
18:21:33.786677 IP 192.168.0.233.ssh > 192.168.0.254.55962: Flags [P.], seq 400:576, ack 1, win 317, length 176
18:21:33.787676 IP 192.168.0.233.ssh > 192.168.0.254.55962: Flags [P.], seq 576:752, ack 1, win 317, length 176
18:21:33.788684 IP 192.168.0.233.ssh > 192.168.0.254.55962: Flags [P.], seq 752:928, ack 1, win 317, length 176
5 packets captured
5 packets received by filter
0 packets dropped by kernel
```

（5）监听指定端口的数据包

```
[root@Mr_chen ~]# tcpdump -nn -c 5 port 22  #-nn不进行DNS解析，不将端口转换成服务名字， port指定监听端口
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes
18:27:25.472624 IP 192.168.0.233.22 > 192.168.0.254.55962: Flags [P.], seq 1886385856:1886386064, ack 322195131, win 317, length 208
18:27:25.472764 IP 192.168.0.254.55962 > 192.168.0.233.22: Flags [.], ack 208, win 522, length 0
18:27:25.473731 IP 192.168.0.233.22 > 192.168.0.254.55962: Flags [P.], seq 208:496, ack 1, win 317, length 288
18:27:25.474746 IP 192.168.0.233.22 > 192.168.0.254.55962: Flags [P.], seq 496:672, ack 1, win 317, length 176
18:27:25.474836 IP 192.168.0.254.55962 > 192.168.0.233.22: Flags [.], ack 672, win 520, length 0
5 packets captured
5 packets received by filter
0 packets dropped by kernel
```

（6）监听指定协议的数据包

```
[root@Mr_chen ~]# tcpdump -n -c 5 arp   #监听arp协议数据包，因此表达式直接写arp即可
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes
18:29:08.056959 ARP, Request who-has 192.168.0.111 tell 192.168.0.1, length 46
18:29:08.978765 ARP, Request who-has 192.168.0.111 tell 192.168.0.1, length 46
18:29:09.900334 ARP, Request who-has 192.168.0.111 tell 192.168.0.1, length 46
18:29:10.822093 ARP, Request who-has 192.168.0.111 tell 192.168.0.1, length 46
18:29:12.050836 ARP, Request who-has 192.168.0.111 tell 192.168.0.1, length 46
5 packets captured
5 packets received by filter
0 packets dropped by kernel
[root@Mr_chen ~]# tcpdump -n -c 5 icmp  #监听icmp数据包（想要查看下面的监控数据，可以使用其他机器ping本机即可）
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes
18:30:55.576828 IP 192.168.0.254 > 192.168.0.233: ICMP echo request, id 1, seq 19956, length 40
18:30:55.576844 IP 192.168.0.233 > 192.168.0.254: ICMP echo reply, id 1, seq 19956, length 40
18:30:56.578427 IP 192.168.0.254 > 192.168.0.233: ICMP echo request, id 1, seq 19958, length 40
18:30:56.578445 IP 192.168.0.233 > 192.168.0.254: ICMP echo reply, id 1, seq 19958, length 40
18:30:57.582167 IP 192.168.0.254 > 192.168.0.233: ICMP echo request, id 1, seq 19960, length 40
5 packets captured
6 packets received by filter
0 packets dropped by kernel
```

> 常见的协议关键字有ip，arp，icmp，tcp，udp等类型

（7）利用tcpdump抓包详解tcp/ip连接和断开过程的案例

1）正常的TCP连接的三个阶段

- [x] :TCP三次握手
- [x] :数据传送
- [x] :TCP四次断开

2）TCP连接图示

> TCP连接的状态机制如下图所示

![QQ截图20180303114730.png-137.5kB](http://static.zybuluo.com/chensiqi/72miqcwsejm775vv30imxr4f/QQ%E6%88%AA%E5%9B%BE20180303114730.png)

3）TCP的状态标识

- [x] SYN:（同步序列编号，Synchronize Sequence Numbers）该标志仅在三次握手建立TCP连接时有效。表示一个新的TCP连接请求
- [x] ACK：（确认编号，Acknowledgement Number）是对TCP请求的确认标志，同时提示对端系统已经成功接收了所有的数据。
- [x] FIN：（结束标志，FINish）用来结束一个TCP回话。但对应端口仍然处于开放状态，准备接收后续数据。

4）使用tcpdump对tcp数据进行抓包

```
[root@Mr_chen www]# tcpdump tcp port 80 or dst 192.168.0.114 -i eth0 -n
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes
#抓包分析：三次握手过程
22:38:18.564320 ARP, Reply 192.168.0.233 is-at 00:0c:29:a8:ca:50, length 28 
#发送了一个ARP响应包给目标MAC地址，告知对方本机的MAC地址
22:38:18.564418 IP 192.168.0.114.52367 > 192.168.0.233.http: Flags [S], seq 3675775834, win 14600, options [mss 1460,sackOK,TS val 4294710555 ecr 0,nop,wscale 6], length 0 
#IP为192.168.0.114（client）通过临时端口52367向本机192.168.0.233（server）的80监听端口发起连接，client的初始包序号为3675775834，滑动窗口大小为14600字节（即TCP接收缓冲区的大小，用于TCP拥塞控制），mss大小为1460（即可接收的最大包长度），[S]=[SYN](发起连接标志)
22:38:18.564434 IP 192.168.0.233.http > 192.168.0.114.52367: Flags [S.], seq 2909831439, ack 3675775835, win 14480, options [mss 1460,sackOK,TS val 15157720 ecr 4294710555,nop,wscale 6], length 0
#Server的响应连接，同时带上上一个包的ack信息（为client端的初始包序号+1，即3675775835，也就是server端下次等待接收这个包序号的包，用于TCP字节流的顺序控制。Server端的初始包序号为2909831439，mss也是1460）
22:38:18.564541 IP 192.168.0.114.52367 > 192.168.0.233.http: Flags [.], ack 1, win 229, options [nop,nop,TS val 4294710556 ecr 15157720], length 0
#Client端再次确认，tcp三次握手完成。“.”表示没有任何标识
```

**以下是数据传输过程：**

```
22:38:18.564654 IP 192.168.0.114.52367 > 192.168.0.233.http: Flags [P.], seq 1:169, ack 1, win 229, options [nop,nop,TS val 4294710557 ecr 15157720], length 168
#Client端发请求包，包长度是168字节。[P]=[push]（传送数据标志）
22:38:18.564658 IP 192.168.0.233.http > 192.168.0.114.52367: Flags [.], ack 169, win 243, options [nop,nop,TS val 15157720 ecr 4294710557], length 0  #Server端回应Client端表示收到请求，并确认已经收到了之前的168字节
22:38:18.564707 IP 192.168.0.233.http > 192.168.0.114.52367: Flags [P.], seq 1:237, ack 169, win 243, options [nop,nop,TS val 15157720 ecr 4294710557], length 236    #Server回包，包长度236字节
22:38:18.564755 IP 192.168.0.233.http > 192.168.0.114.52367: Flags [P.], seq 237:258, ack 169, win 243, options [nop,nop,TS val 15157720 ecr 4294710557], length 21
22:38:18.564773 IP 192.168.0.114.52367 > 192.168.0.233.http: Flags [.], ack 237, win 245, options [nop,nop,TS val 4294710557 ecr 15157720], length 0
22:38:18.564818 IP 192.168.0.114.52367 > 192.168.0.233.http: Flags [.], ack 258, win 245, options [nop,nop,TS val 4294710557 ecr 15157720], length 0
```

**以下是4次挥手过程：**

```
22:38:18.564946 IP 192.168.0.114.52367 > 192.168.0.233.http: Flags [F.], seq 169, ack 258, win 245, options [nop,nop,TS val 4294710557 ecr 15157720], length 0  
#Client端发送关闭连接请求，F=FIN（断开连接标志）
22:38:18.564956 IP 192.168.0.233.http > 192.168.0.114.52367: Flags [F.], seq 258, ack 170, win 243, options [nop,nop,TS val 15157720 ecr 4294710557], length 0
#Server端回应并确认了Client端的断开连接请求，并且也发送了FIN标志关闭。（只有当服务器传输未完成时，此处才会出现两次挥手，如果Clinet发起断开请求时，服务器已经传输数据完成，则此处服务端会直接回应关闭标志FIN）
22:38:18.565022 IP 192.168.0.114.52367 > 192.168.0.233.http: Flags [.], ack 259, win 245, options [nop,nop,TS val 4294710557 ecr 15157720], length 0
#Clinet端响应ack，关闭连接的四次挥手完成
```

> **提示：**
>  tcpdump是一个非常强大并且好用的命令，请同学们多花精力来掌握，当然，要想掌握好，还需要一定的网络知识才行

## 三，Linux核心系统管理命令

### 3.1 lsof：查看进程打开的文件

#### 3.1.1 命令详解

**功能说明：**

> lsof全名为list open files，也就是列举系统中已经被打开的文件，通过lsof命令，就可以根据文件找到对应的进程信息，也可以根据进程信息找到进程打开的文件

**选项说明：**

| 参数选项    | 解释说明                                                     |
| ----------- | ------------------------------------------------------------ |
| -c <进程名> | 显示指定的进程名所打开的文件                                 |
| -p <进程号> | 显示指定的进程号所打开的文件                                 |
| -i          | 通过监听指定的协议，端口和主机等信息，显示符合条件的进程信息 |
| -u          | 显示指定用户使用的文件                                       |
| -U          | 显示所有socket文件                                           |

#### 3.1.2 使用范例

（1）显示使用文件的进程

```
[root@Mr_chen ~]# lsof /var/log/messages    #显示使用文件的进程
COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF   NODE NAME
rsyslogd 870 root    1w   REG  253,0   501224 262654 /var/log/messages
```

> 如果想知道某个特定的文件是由哪个进程在使用，就可以通过“lsof 文件名”的方式来得到。从上面的输出可以得知，/var/log/messages文件是由rsyslogd进程在使用。
>  输出中每列的含义具体如下：
>
> - [x] COMMAND:命令，进程的名称。
> - [x] PID:进程号。
> - [x] USER:进程的所有者。
> - [x] FD:文件描述符，它又包含如下内容
>   - 0：表示标准输出。
>   - 1：表示标准输入。
>   - 2：表示标准错误。
>   - u：表示该文件被打开并处于读取/写入模式
>   - r：表示该文件被打开并处于只读模式
>   - w：表示该文件被打开并处于写入模式
> - [x] TYPE:文件类型，REG（regular）为普通文件
> - [x] DEVICE:指定磁盘的名称。
> - [x] SIZE/OFF:文件的大小
> - [x] NODE:索引节点
> - [x] NAME:文件名称

（2）显示指定进程所打开的文件

```
[root@Mr_chen ~]# lsof -c rsyslog   #使用-c选项显示指定进程所打开的文件
COMMAND  PID USER   FD   TYPE             DEVICE SIZE/OFF       NODE NAME
rsyslogd 870 root  cwd    DIR              253,0     4096          2 /
rsyslogd 870 root  rtd    DIR              253,0     4096          2 /
rsyslogd 870 root  txt    REG              253,0   396064     130951 /sbin/rsyslogd
rsyslogd 870 root  mem    REG              253,0    27232     393534 /lib64/rsyslog/imklog.so
rsyslogd 870 root  mem    REG              253,0   340568     393540 /lib64/rsyslog/imuxsock.so
rsyslogd 870 root  mem    REG              253,0    65928     392495 /lib64/libnss_files-2.12.so
rsyslogd 870 root  mem    REG              253,0    26984     393541 /lib64/rsyslog/lmnet.so
rsyslogd 870 root  mem    REG              253,0  1921216     392479 /lib64/libc-2.12.so
rsyslogd 870 root  mem    REG              253,0    90880     392452 /lib64/libgcc_s-4.4.7-20120601.so.1
rsyslogd 870 root  mem    REG              253,0    43832     392507 /lib64/librt-2.12.so
rsyslogd 870 root  mem    REG              253,0    19536     392485 /lib64/libdl-2.12.so
rsyslogd 870 root  mem    REG              253,0   142640     392503 /lib64/libpthread-2.12.so
rsyslogd 870 root  mem    REG              253,0    88600     392529 /lib64/libz.so.1.2.3
rsyslogd 870 root  mem    REG              253,0   154520     392472 /lib64/ld-2.12.so
rsyslogd 870 root    0u  unix 0xffff880037d8b6c0      0t0       8910 /dev/log
rsyslogd 870 root    1w   REG              253,0   501224     262654 /var/log/messages
rsyslogd 870 root    2w   REG              253,0     5164     262655 /var/log/secure
rsyslogd 870 root    3r   REG                0,3        0 4026532040 /proc/kmsg
rsyslogd 870 root    4w   REG              253,0    18512     262652 /var/log/cron
```

（3）显示指定进程号说打开的文件

```
[root@Mr_chen ~]# lsof -p 870   #使用-p选项显示指定进程号所打开的文件
COMMAND  PID USER   FD   TYPE             DEVICE SIZE/OFF       NODE NAME
rsyslogd 870 root  cwd    DIR              253,0     4096          2 /
rsyslogd 870 root  rtd    DIR              253,0     4096          2 /
rsyslogd 870 root  txt    REG              253,0   396064     130951 /sbin/rsyslogd
rsyslogd 870 root  mem    REG              253,0    27232     393534 /lib64/rsyslog/imklog.so
rsyslogd 870 root  mem    REG              253,0   340568     393540 /lib64/rsyslog/imuxsock.so
rsyslogd 870 root  mem    REG              253,0    65928     392495 /lib64/libnss_files-2.12.so
rsyslogd 870 root  mem    REG              253,0    26984     393541 /lib64/rsyslog/lmnet.so
rsyslogd 870 root  mem    REG              253,0  1921216     392479 /lib64/libc-2.12.so
rsyslogd 870 root  mem    REG              253,0    90880     392452 /lib64/libgcc_s-4.4.7-20120601.so.1
rsyslogd 870 root  mem    REG              253,0    43832     392507 /lib64/librt-2.12.so
rsyslogd 870 root  mem    REG              253,0    19536     392485 /lib64/libdl-2.12.so
rsyslogd 870 root  mem    REG              253,0   142640     392503 /lib64/libpthread-2.12.so
rsyslogd 870 root  mem    REG              253,0    88600     392529 /lib64/libz.so.1.2.3
rsyslogd 870 root  mem    REG              253,0   154520     392472 /lib64/ld-2.12.so
rsyslogd 870 root    0u  unix 0xffff880037d8b6c0      0t0       8910 /dev/log
rsyslogd 870 root    1w   REG              253,0   501224     262654 /var/log/messages
rsyslogd 870 root    2w   REG              253,0     5164     262655 /var/log/secure
rsyslogd 870 root    3r   REG                0,3        0 4026532040 /proc/kmsg
rsyslogd 870 root    4w   REG              253,0    18512     262652 /var/log/cron
```

（4）监听指定的协议，端口和主机等信息，显示符合条件的进程信息

> 在讲解范例之前，我们先来看看相应语法格式：
>  `lsof -i [46] [protocol] [@hostname] [:service|port]`
>  其中各项的含义如下：
>
> - [x] 46:4代表IPv4，6代表IPv6
> - [x] protocol:传输协议，可以是TCP或UDP
> - [x] hostname:主机名称或者IP地址
> - [x] service:进程的服务名，例如NFS，SSH和FTP等。
> - [x] port:系统中与服务对应的端口号。例如HTTP服务默认对应的端口号为80，SSH服务默认对应的端口号为22.

```
[root@Mr_chen ~]# lsof -i   #查看所有进程
COMMAND PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
sshd    885 root    3u  IPv4   8948      0t0  TCP *:ssh (LISTEN)
sshd    885 root    4u  IPv6   8950      0t0  TCP *:ssh (LISTEN)
sshd    918 root    3r  IPv4   9075      0t0  TCP localhost:ssh->localhost:54216 (ESTABLISHED)
[root@Mr_chen ~]# lsof -i tcp   #显示所有tcp网络连接的进程信息
COMMAND PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
sshd    885 root    3u  IPv4   8948      0t0  TCP *:ssh (LISTEN)
sshd    885 root    4u  IPv6   8950      0t0  TCP *:ssh (LISTEN)
sshd    918 root    3r  IPv4   9075      0t0  TCP localhost:ssh->localhost:54216 (ESTABLISHED)
[root@Mr_chen ~]# lsof -i:22    #显示端口为22的进程，这条命令很常用
COMMAND PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
sshd    885 root    3u  IPv4   8948      0t0  TCP *:ssh (LISTEN)
sshd    885 root    4u  IPv6   8950      0t0  TCP *:ssh (LISTEN)
sshd    918 root    3r  IPv4   9075      0t0  TCP localhost:ssh->localhost:54216 (ESTABLISHED)
[root@Mr_chen ~]# lsof -i tcp:22    #显示同时满足TCP和端口为22的进程
COMMAND PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
sshd    885 root    3u  IPv4   8948      0t0  TCP *:ssh (LISTEN)
sshd    885 root    4u  IPv6   8950      0t0  TCP *:ssh (LISTEN)
sshd    918 root    3r  IPv4   9075      0t0  TCP localhost:ssh->localhost:54216 (ESTABLISHED)
```

（5）显示指定用户使用的文件

```
[root@Mr_chen ~]# lsof -u Mr_chen   #使用-u选项显示Mr_chen用户使用的文件
COMMAND  PID    USER   FD   TYPE DEVICE SIZE/OFF   NODE NAME
bash    1012 Mr_chen  cwd    DIR  253,0     4096 138686 /home/Mr_chen
bash    1012 Mr_chen  rtd    DIR  253,0     4096      2 /
bash    1012 Mr_chen  txt    REG  253,0   903336 786016 /bin/bash
bash    1012 Mr_chen  mem    REG  253,0 99158576 655748 /usr/lib/locale/locale-archive
bash    1012 Mr_chen  mem    REG  253,0    65928 392495 /lib64/libnss_files-2.12.so
bash    1012 Mr_chen  mem    REG  253,0  1921216 392479 /lib64/libc-2.12.so
bash    1012 Mr_chen  mem    REG  253,0    19536 392485 /lib64/libdl-2.12.so
bash    1012 Mr_chen  mem    REG  253,0   135896 392521 /lib64/libtinfo.so.5.7
bash    1012 Mr_chen  mem    REG  253,0   154520 392472 /lib64/ld-2.12.so
bash    1012 Mr_chen  mem    REG  253,0    26060 916570 /usr/lib64/gconv/gconv-modules.cache
bash    1012 Mr_chen    0u   CHR  136,1      0t0      4 /dev/pts/1
bash    1012 Mr_chen    1u   CHR  136,1      0t0      4 /dev/pts/1
bash    1012 Mr_chen    2u   CHR  136,1      0t0      4 /dev/pts/1
bash    1012 Mr_chen  255u   CHR  136,1      0t0      4 /dev/pts/1
```

（6）显示所有socket文件

```
[root@Mr_chen ~]# lsof -U   #使用-U选项显示所有socket文件
COMMAND   PID USER   FD   TYPE             DEVICE SIZE/OFF  NODE NAME
init        1 root    7u  unix 0xffff880037afa680      0t0  7510 socket
udevd     360 root    4u  unix 0xffff880037afa980      0t0  7857 socket
udevd     360 root    8u  unix 0xffff880037afac80      0t0  7873 socket
udevd     360 root    9u  unix 0xffff880037afa080      0t0  7874 socket
udevd     635 root    9u  unix 0xffff880037afa080      0t0  7874 socket
rsyslogd  870 root    0u  unix 0xffff880037d8b6c0      0t0  8910 /dev/log
crond     893 root    4u  unix 0xffff880037d8b3c0      0t0  8976 socket
sshd      918 root    4w  unix 0xffff880037d8b0c0      0t0  9125 socket
anacron   983 root    4u  unix 0xffff880037d8b9c0      0t0 10018 socket
su       1011 root    3u  unix 0xffff880037d8bcc0      0t0 10151 socket
```

### 3.2 free:查看系统内存信息

#### 3.2.1 命令详解

**功能说明：**

> free命令用于显示系统内存状态，具体包括系统物理内存，虚拟内存，共享内存和系统缓存等。

**选项说明：**

| 参数选项      | 解释说明（带@的为重点）                   |
| ------------- | ----------------------------------------- |
| -b            | 以Byte为单位显示内存的使用情况            |
| -m            | 以MB为单位显示内存的使用情况@             |
| -K            | 以KB为单位显示内存的使用情况              |
| -h            | 以人类可读的形式显示内存的使用情况@       |
| -t            | 显示内存总和列                            |
| -s <间隔秒数> | 根据指定的间隔秒数持续显示内存的使用情况@ |
| -o            | 不显示系统缓冲区列                        |

#### 3.2.2 使用范例

（1）查看系统内存

```
[root@Mr_chen ~]# free  #不加参数默认显示的是字节数，很难读懂
             total       used       free     shared    buffers     cached
Mem:       1004412      85788     918624          0       6168      22904
-/+ buffers/cache:      56716     947696
Swap:      2031608          0    2031608
[root@Mr_chen ~]# free -m   #使用-m选项，以MB为单位显示内存的使用情况
             total       used       free     shared    buffers     cached
Mem:           980         83        897          0          6         22
-/+ buffers/cache:         55        925
Swap:         1983          0       1983
```

> 针对上面的输出，有以下说明
>
> - [x] Linux系统的特性是将不用的物理内存缓存起来，因此897MB不是系统的真实剩余内存。
> - [x] 系统真正可用的内存为925MB
> - [x] buffers为写入数据缓冲区
> - [x] cache为读取数据缓存区

（2）定时查询内存

```
[root@Mr_chen ~]# free -s 10    #使用-s选项定时刷新内存的使用情况，单位为秒
             total       used       free     shared    buffers     cached
Mem:       1004412      85888     918524          0       6168      22932
-/+ buffers/cache:      56788     947624
Swap:      2031608          0    2031608
```

### 3.3 iftop：动态显示网络接口流量信息

#### 3.3.1 命令详解

**功能说明：**

> - iftop是一款实时流量监控工具，可用于监控TCP/IP连接等，必须以root用户的身份运行。
> - 一般最小化安装系统都是没有这个命令的，需要使用yum命令额外安装，而且还要从epel源下载。
>    epel源的安装帮助请参见：http://mirrors.aliyun.com/help/epel
>    安装iftop命令的步骤请参见：
>    `wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-6.repo`
>    `yum -y install iftop`

**选项说明：**

| 参数选项   | 解释说明（带@的为重点）                                      |
| ---------- | ------------------------------------------------------------ |
| -i         | 指定监听的网络接口@                                          |
| -n         | 不进行DNS解析@                                               |
| -N         | 不将端口号解析成服务名@                                      |
| -B         | 以byte为单位显示流量（默认是bit）@                           |
| -p         | 设置网卡为混杂模式，以便不直接通过指定接口传递的流量也能被计数 |
| -P（大写） | 显示端口号@                                                  |
| -m         | 设置界面最上边的刻度的最大值，刻度分为五个大段显示           |
| -F         | 显示特定网段的进出流量                                       |

#### 3.3.2 使用范例

（1）不接任何参数启动iftop命令监控流量。

```
[root@Mr_chen yum.repos.d]# iftop
interface: eth0 #默认监听系统的第一块网卡，可以使用-i选项指定监听网卡
IP address is: 192.168.0.233
MAC address is: 00:0c:29:a8:ca:50
```

![QQ截图20180306231637.png-16.2kB](http://static.zybuluo.com/chensiqi/gblx8hz6y1c31riknnxcejlt/QQ%E6%88%AA%E5%9B%BE20180306231637.png)

> 上图为iftop界面，相关说明如下：
>
> - [x] 界面上显示的是类似刻度尺的刻度范围，是以标尺的形式显示流量图形的长条
> - [x] 中间的<=或=>这两个左右箭头，表示的是流量的反向
> - [x] TX:发送流量
> - [x] RX:接收流量
> - [x] TOTAL:总流量
> - [x] Cum:运行iftop到目前时间的总流量
> - [x] peak:流量峰值
> - [x] rates:分别表示过去2s，10s，40s的平均流量

（2）常用命令组合

```
[root@Mr_chen yum.repos.d]# iftop -nNBP
interface: eth0
IP address is: 192.168.0.233
MAC address is: 00:0c:29:a8:ca:50
```

![QQ截图20180306231637.png-17.2kB](http://static.zybuluo.com/chensiqi/vyeev6k720ye6sfanncbz32o/QQ%E6%88%AA%E5%9B%BE20180306231637.png)

> 命令说明具体如下：
>
> - [x] -n:不进行DNS解析，显示IP数字地址
> - [x] -N:显示数字形式的端口号
> - [x] -P:显示端口号
> - [x] -B:默认是以bit为单位显示流量，需要经过计算才能符合我们的认知，但是使用-B选项就会直接显示以字节为单位的流量。

### 3.4 vmstat：虚拟内存统计

#### 3.4.1 命令详解

**功能说明：**

> vmstat是Virtual Memory Statistics（虚拟内存统计）的缩写，利用vmstat命令可以对操作系统的内存信息，进程状态和CPU活动等进行监视。但是只能对系统的整体情况进行统计，无法对某个进程进行深入分析。

**选项说明：**

| 参数选项 | 解释说明（带@的为重点）                                      |
| -------- | ------------------------------------------------------------ |
| -a       | 显示活跃和非活跃内存                                         |
| -f       | 显示从系统启动至今的fork进程数量                             |
| -m       | 显示slab信息                                                 |
| -n       | 只在开始时显示一次各字段名称                                 |
| -s       | 显示内存相关统计信息及多种系统活动数量@                      |
| -d       | 显示磁盘相关统计信息                                         |
| -p       | 显示指定磁盘分区统计信息                                     |
| -S       | 使用指定单位显示。参数有k，K，m，M，分别代表1000，1024，1000000，1048576字节（byte）。默认单位为K（1024byte） |
| -t       | 统计信息带上时间戳                                           |

#### 3.4.2 使用范例

（1）显示虚拟内存的使用情况

```
[root@Mr_chen ~]# vmstat    #如果省略“间隔时间”和“次数”的参数，则仅显示一次报告后就退出
procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 0  0      0 915796   8792  22900    0    0  1188    54  203  474  2  6 90  1  0
 [root@Mr_chen ~]# vmstat 5 #表示每5秒钟更新一次输出信息，循环输出，按Ctrl + C组合键停止输出
procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 0  0      0 915796   8792  22928    0    0   343    24   64  144  1  2 97  0  0    
[root@Mr_chen ~]# vmstat 5 6    #表示每5秒钟更新一次输出信息，统计6次后停止输出
procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 0  0      0 915796   8792  22928    0    0   781    53  137  316  1  4 94  1  0    
```

> 以下是命令结果的详解说明
>  第1列：procs
>
> - [x] r列表示运行和等待CPU时间片的进程数。
> - [x] b列表示正在等待资源的进程数。
>
> 第2列：memory
>
> - [x] swpd列表示使用虚拟内存的大小。
> - [x] free列表示当前空闲的物理内存数量.
> - [x] buff列表示buffers的内存数量.
> - [x] cache列表示cache的内存数量.
>
> 第3列：swap
>
> - [x] si(swap in)列表示由磁盘调入内存，也就是内存进入内存交换区的数量。
> - [x] so(swap out)列表示由内存调入磁盘，也就是内存交换区进入内存的数量。
>
> 第4列：I/O项显示磁盘读写状况
>
> - [x] bi列表示从块设备读入数据的总量（即读磁盘）（块/s）
> - [x] bo列表示写入块设备的数据总量（即写磁盘））（块/s）
>
> 第5列：system显示采集间隔内发生的中断数
>
> - [x] in列表示在某一时间间隔中观测到的每秒设备中断数。
> - [x] cs列表示每秒产生的上下文切换次数。
>
> 第6列：CPU项显示了CPU的使用状态
>
> - [x] us列显示了用户进程消耗的CPU时间百分比。
> - [x] sy列显示了系统（内核）进程消耗的CPU时间百分比。
> - [x] id列显示了CPU处在空闲状态的时间百分比。
> - [x] wa列显示了I/O等待所占用的CPU时间百分比
> - [x] st列显示了虚拟机占用的CPU时间的百分比。

（2）显示活跃和非活跃内存

```
[root@Mr_chen ~]# vmstat -a 2 5
procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----
 r  b   swpd   free  inact active   si   so    bi    bo   in   cs us sy id wa st
 0  0      0 915324  19284  18180    0    0     5     0    6    9  0  0 100  0  0   
 0  0      0 915284  19284  18180    0    0     0     0   10    9  0  0 100  0  0   
 0  0      0 915284  19284  18180    0    0     0     0   10   10  0  0 100  0  0   
 0  0      0 915284  19284  18212    0    0     0     0    9   10  0  0 100  0  0   
 0  0      0 915284  19284  18212    0    0     0     0    9   11  0  0 100  0  0   
```

> 使用-a选项显示活跃和非活跃内存时，所显示的内容除去增加了inact和active之外，其他显示内容与范例11-12相同。
>  memory列增加了inact和active两列，其说明具体如下。
>
> - [x] inact:非活跃的内存大小（当使用-a选项时显示）
> - [x] active:活跃的内存大小（当使用-a选项时显示）

（3）查看内存使用的详细信息

```
[root@Mr_chen ~]# vmstat -s
      1004412  total memory
        89096  used memory
        18196  active memory
        19268  inactive memory
       915316  free memory
         8816  buffer memory
        23244  swap cache
      2031608  total swap
            0  used swap
      2031608  free swap
......
```

> 这些信息分别来自于/proc/meminfo,/proc/stat和/proc/vmstat

（4）查看磁盘的读/写

```
[root@Mr_chen ~]# vmstat -d
disk- ------------reads------------ ------------writes----------- -----IO------
       total merged sectors      ms  total merged sectors      ms    cur    sec
ram0       0      0       0       0      0      0       0       0      0      0
ram1       0      0       0       0      0      0       0       0      0      0
ram2       0      0       0       0      0      0       0       0      0      0
ram3       0      0       0       0      0      0       0       0      0      0
ram4       0      0       0       0      0      0       0       0      0      0
ram5       0      0       0       0      0      0       0       0      0      0
ram6       0      0       0       0      0      0       0       0      0      0
ram7       0      0       0       0      0      0       0       0      0      0
ram8       0      0       0       0      0      0       0       0      0      0
ram9       0      0       0       0      0      0       0       0      0      0
ram10      0      0       0       0      0      0       0       0      0      0
ram11      0      0       0       0      0      0       0       0      0      0
ram12      0      0       0       0      0      0       0       0      0      0
ram13      0      0       0       0      0      0       0       0      0      0
ram14      0      0       0       0      0      0       0       0      0      0
ram15      0      0       0       0      0      0       0       0      0      0
loop0      0      0       0       0      0      0       0       0      0      0
loop1      0      0       0       0      0      0       0       0      0      0
loop2      0      0       0       0      0      0       0       0      0      0
loop3      0      0       0       0      0      0       0       0      0      0
disk- ------------reads------------ ------------writes----------- -----IO------
       total merged sectors      ms  total merged sectors      ms    cur    sec
loop4      0      0       0       0      0      0       0       0      0      0
loop5      0      0       0       0      0      0       0       0      0      0
loop6      0      0       0       0      0      0       0       0      0      0
loop7      0      0       0       0      0      0       0       0      0      0
sr0       33      0     264      47      0      0       0       0      0      0
sda     2144   1571   70016     659    411    452    6898     277      0      0
dm-0    2786      0   62426    1755    854      0    6832     583      0      0
dm-1     287      0    2296      35      0      0       0       0      0      0
```

> 这些信息主要来自于/proc/diskstats。其中的merged表示一次来自于合并的写/读请求，系统一般会把多个连接/邻近的读/写请求合并到一起来操作。

（5）查看/dev/sda1磁盘的读写统计信息

```
[root@Mr_chen ~]# vmstat -p /dev/sda1
sda1          reads   read sectors  writes    requested writes
                 431       3518          9         66
```

> 这些信息主要来自于/proc/diskstats。各列的说明具体如下
>
> - [x] reads:来自于该分区的读的次数
> - [x] read sectors:来自于该分区的读扇区的次数
> - [x] writes:来自于该分区的写的次数
> - [x] requested writes:来自于该分区的写请求次数。

### 3.5 mpstat:CPU信息统计

#### 3.5.1 命令详解

**功能说明：**

> - mpstat是Multiprocessor  Statistics的缩写，是一种实时系统监控工具。mpstat命令会输出CPU的一些统计信息，这些信息存放在/proc/stat文件中。在多CPU的系统里，此命令不但能用来查看所有CPU的平均状态信息，而且还能够用来查看特定CPU的信息。
>    mpstat命令的最大特点是：可以查看多核心CPU中每个计算核心的统计数据，而类似命令vmstat只能查看系统整体的CPU情况。

**选项说明：**

| 参数选项 | 解释说明                                                     |
| -------- | ------------------------------------------------------------ |
| -P       | 指定CPU编号，例如：-P 0表示第一个CPU，-P 1表示第二个CPU，-P ALL表示所有CPU |

#### 3.5.2 使用范例

（1）显示CPU信息统计

```
[root@Mr_chen ~]# mpstat    #如果省略“时间间隔”和“次数”参数，则仅显示一次报告后就退出
Linux 2.6.32-431.el6.x86_64 (Mr_chen)   03/10/2018  _x86_64_    (1 CPU)

06:13:34 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest   %idle
06:13:34 PM  all    0.01    0.00    0.06    0.01    0.00    0.00    0.00    0.00   99.93
[root@Mr_chen ~]# mpstat 5 6    #表示每5秒更新一次输出信息，统计6次后停止输出。
Linux 2.6.32-431.el6.x86_64 (Mr_chen)   03/10/2018  _x86_64_    (1 CPU)

06:15:16 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest   %idle
06:15:21 PM  all    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
06:15:26 PM  all    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
06:15:31 PM  all    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
06:15:36 PM  all    0.00    0.00    0.20    0.00    0.00    0.00    0.00    0.00   99.80
06:15:41 PM  all    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
06:15:46 PM  all    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
Average:     all    0.00    0.00    0.03    0.00    0.00    0.00    0.00    0.00   99.97
```

> 以下是命令结果的详细说明
>  第1列：06：13：34 PM，表示当前时间
>  第2列：CPU，all表示所有CPU，0表示第一个CPU...
>  后面9列的含义分别如下：
>
> - [x] %usr:用户进程消耗的CPU时间百分比。
> - [x] %nice:改变过优先级的进程占用的CPU时间百分比
> - [x] %sys:系统（内核）进程消耗的CPU时间百分比
> - [x] %iowait:IO等待所占用的CPU时间百分比
> - [x] %irq:硬中断占用的CPU时间百分比
> - [x] %soft:软中断占用的CPU时间百分比
> - [x] %steal:虚拟机强制CPU等待的时间百分比
> - [x] %guest:虚拟机占用CPU时间的百分比
> - [x] %idle:CPU处于空闲状态的时间百分比

（2）显示指定CPU信息的统计

```
[root@Mr_chen ~]# mpstat -P 0   #显示第一个CPU信息
Linux 2.6.32-431.el6.x86_64 (Mr_chen)   03/10/2018  _x86_64_    (1 CPU)

06:29:46 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest   %idle
06:29:46 PM    0    0.01    0.00    0.05    0.01    0.00    0.00    0.00    0.00   99.93
```

### 3.6 iostat：I/O信息统计

#### 3.6.1 命令详解

**功能说明：**

> iostat是I/O  statistics（输入/输出统计）的缩写，其主要功能是对系统的磁盘I/O操作进行监视。它的输出主要是显示磁盘读写操作的统计信息，同时也会给出CPU的使用情况。同vmstat命令一样，iostat命令也不能对某个进程进行深入分析，仅会对系统的整体情况进行分析。

**选项说明：**

| 参数选项  | 解释说明（带@为重点）                          |
| --------- | ---------------------------------------------- |
| -c        | 显示CPU的使用情况@                             |
| -d        | 显示磁盘的使用情况@                            |
| -k        | 每秒以kB为单位显示数据                         |
| -m        | 每秒以MB为单位显示数据                         |
| -n        | 显示NFS的使用情况                              |
| -t        | 显示每次统计的执行时间                         |
| -p device | 指定要统计的磁盘设备名称，默认为所有的磁盘设备 |
| -x        | 显示扩展统计                                   |

#### 3.6.2 使用范例

（1）显示所有设备的负载情况

```
[root@Mr_chen ~]# iostat    #如果省略“时间间隔”和“次数”参数，则仅显示一次报告后就退出
Linux 2.6.32-431.el6.x86_64 (Mr_chen)   03/10/2018  _x86_64_    (1 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           0.02    0.00    0.05    0.01    0.00   99.93

Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn
scd0              0.02         0.13         0.00       1976          0
sda               0.34        28.21         7.76     445866     122724
dm-0              1.30        27.73         7.76     438306     122664
dm-1              0.02         0.15         0.00       2296          0
```

> 以下是命令结果说明
>  第1~2行中各列的含义具体如下
>
> - [x] %user : 用户进程消耗的CPU时间百分比
> - [x] %nice : 改变过优先级的进程占用的CPU时间百分比
> - [x] %system : 系统（内核）进程消耗的CPU时间百分比
> - [x] %iowait : IO等待所占用的CPU时间百分比
> - [x] %steal : 虚拟机强制CPU等待的时间百分比
> - [x] %idle : CPU处在空闲状态的时间百分比
>    第3~4行中各列的含义如下
> - [x] tps : 表示该设备每秒的传输次数，“一次传输”的意思是“一次I/O请求”，多个逻辑请求可能会被合并为“一次I/O请求”，“一次传输”请求的大小是未知的。
> - [x] Blk_read/s : 表示每秒读取的数据块数
> - [x] Blk_wrtn/s : 表示每秒写入的数据块数
> - [x] Blk_read : 表示读取的所有块数
> - [x] Blk_wrtn : 表示写入的所有块数

（2）定时显示所有信息

```
[root@Mr_chen ~]#  iostat 2 3   #每隔2秒刷新显示一次，共显示3次
Linux 2.6.32-431.el6.x86_64 (Mr_chen)   03/10/2018  _x86_64_    (1 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           0.01    0.00    0.04    0.00    0.00   99.94

Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn
scd0              0.02         0.09         0.00       1976          0
sda               0.25        19.82         5.51     445866     123988
dm-0              0.92        19.48         5.51     438306     123928
dm-1              0.01         0.10         0.00       2296          0

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           0.00    0.00    0.00    0.00    0.00  100.00

Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn
scd0              0.00         0.00         0.00          0          0
sda               0.00         0.00         0.00          0          0
dm-0              0.00         0.00         0.00          0          0
dm-1              0.00         0.00         0.00          0          0

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           0.00    0.00    0.50    0.00    0.00   99.50

Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn
scd0              0.00         0.00         0.00          0          0
sda               0.00         0.00         0.00          0          0
dm-0              0.00         0.00         0.00          0          0
dm-1              0.00         0.00         0.00          0          0
```

（3）只显示磁盘统计信息

```
[root@Mr_chen ~]# iostat -d #选项-d只显示磁盘的统计信息
Linux 2.6.32-431.el6.x86_64 (Mr_chen)   03/10/2018  _x86_64_    (1 CPU)

Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn
scd0              0.02         0.09         0.00       1976          0
sda               0.24        19.50         5.43     445866     124108
dm-0              0.91        19.17         5.42     438306     124048
dm-1              0.01         0.10         0.00       2296          0
[root@Mr_chen ~]# iostat -d -k  #选项-k以KB为单位显示数据
Linux 2.6.32-431.el6.x86_64 (Mr_chen)   03/10/2018  _x86_64_    (1 CPU)

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
scd0              0.02         0.04         0.00        988          0
sda               0.24         9.72         2.70     222933      62054
dm-0              0.91         9.55         2.70     219153      62024
dm-1              0.01         0.05         0.00       1148          0
[root@Mr_chen ~]# iostat -d -m  #选项-m以MB为单位显示数据
Linux 2.6.32-431.el6.x86_64 (Mr_chen)   03/10/2018  _x86_64_    (1 CPU)

Device:            tps    MB_read/s    MB_wrtn/s    MB_read    MB_wrtn
scd0              0.02         0.00         0.00          0          0
sda               0.24         0.01         0.00        217         60
dm-0              0.90         0.01         0.00        214         60
dm-1              0.01         0.00         0.00          1          0
```

（4）查看扩展信息

```
[root@Mr_chen ~]# iostat -d -x -k   #选项-x显示扩展信息
Linux 2.6.32-431.el6.x86_64 (Mr_chen)   03/10/2018  _x86_64_    (1 CPU)

Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await  svctm  %util
scd0              0.00     0.00    0.02    0.00     0.04     0.00     5.41     0.00    1.09   1.09   0.00
sda               0.08     0.61    0.18    0.05     9.49     2.65   102.62     0.00    0.79   0.42   0.01
dm-0              0.00     0.00    0.22    0.66     9.33     2.65    27.03     0.01    6.17   0.11   0.01
dm-1              0.00     0.00    0.01    0.00     0.05     0.00     8.00     0.00    0.24   0.13   0.00
```

> 以下是命令结果说明
>
> - [x] rrqm/s:每秒进行merge的读操作数目
> - [x] wrqm/s:每秒进行merge的写操作数目
> - [x] r/s:每秒完成的读I/O设备次数
> - [x] w/s:每秒完成的写I/O设备次数
> - [x] rkB/s:每秒读入的千字节数
> - [x] wkB/s:每秒写入的千字节数
> - [x] avgrq-sz:设备平均每次进行I/O操作的数据大小（扇区）
> - [x] avgqu-sz:平均I/O队列长度
> - [x] await:设备平均每次I/O操作的等待时间（毫秒）
> - [x] svctm:设备平均每次I/O操作的服务时间（毫秒）
> - [x] %util:每秒钟用于I/O操作的百分比

（5）只查看CPU的统计信息

```
[root@Mr_chen ~]# iostat -c #使用-c选项只显示系统CPU的统计信息
Linux 2.6.32-431.el6.x86_64 (Mr_chen)   03/10/2018  _x86_64_    (1 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           0.01    0.00    0.04    0.00    0.00   99.95
```

### 3.7 iotop：动态显示磁盘I/O统计信息

#### 3.7.1 命令详解

**功能说明：**

> iotop命令是一款实时监控磁盘I/O的工具，但必须以root用户的身份运行。使用iotop命令可以很方便地查看每个进程使用磁盘I/O的情况。
>  最小化安装系统一般是没有这个命令的，需要使用yum命令额外安装，安装命令如下：`yum -y install iotop`

**选项说明：**

| 参数选项   | 解释说明（带@为重点）                          |
| ---------- | ---------------------------------------------- |
| -o         | 显示正在使用I/O的进程或者线程，默认是显示所有@ |
| -d         | 设置显示的间隔秒数                             |
| -p         | 只显示指定PID的信息@                           |
| -u         | 显示指定用户的信息                             |
| -P（大写） | 只显示进程，一般是显示所有的线程               |
| -a         | 显示从iotop启动后每个线程完成了的I/O总数       |
| -k         | 设置显示单位为KB                               |
| -t         | 在每一行前添加一个当前的时间                   |

#### 3.7.2 使用范例

（1）不接任何参数启动iotop命令

```repl
[root@Mr_chen ~]# iotop     

Total DISK READ: 0.00 B/s | Total DISK WRITE: 0.00 B/s
  TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO>    COMMAND                                                                      
    1 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % init
    2 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kthreadd]
    3 rt/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [migration/0]
    4 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [ksoftirqd/0]
    5 rt/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [migration/0]
    6 rt/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [watchdog/0]
    7 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [events/0]
    8 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [cgroup]
    9 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [khelper]
   10 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [netns]
   11 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [async/mgr]
   12 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [pm]
   13 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [sync_supers]
   14 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [bdi-default]
   15 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kintegrityd/0]
   16 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kblockd/0]
   17 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kacpid]
   18 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kacpi_notify]
   19 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kacpi_hotplug]
   20 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [ata_aux]
   21 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [ata_sff/0]
   22 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [ksuspend_usbd]
   23 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [khubd]
   24 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kseriod]
```

> 以下是命令结果的具体说明
>
> - [x] Total DISK READ:总的磁盘读取速度
> - [x] Total DISK WRITE:总的磁盘写入速度
> - [x] TID:进程pid值
> - [x] PRIO:优先级
> - [x] USER:用户
> - [x] DISK READ:磁盘读取速度
> - [x] DISK WRITE:磁盘写入速度
> - [x] SWAPIN:从swap分区读取数据占用的百分比
> - [x] IO:I/O占用的百分比
> - [x] COMMAND:消耗I/O的进程名

### 3.8 sar：收集系统信息

#### 3.8.1 命令详解

**功能说明：**

> 通过sar命令，可以全面地获取系统的CPU，运行队列，磁盘I/O，分页（交换区），内存，CPU中断和网络等性能数据

**选项说明：**

| 参数选项    | 解释说明（带@的为重点）                              |
| ----------- | ---------------------------------------------------- |
| -A          | 显示系统所有资源设备（CPU，内存，磁盘）的运行状态    |
| -u          | 显示系统所有CPU在采样时间内的负载状态@               |
| -P          | 显示当前系统中指定CPU的使用情况                      |
| -d          | 显示系统所有硬盘设备在采样时间内的使用状况@          |
| -r          | 显示在采样时间内系统内存的使用状况@                  |
| -b          | 显示在采样时间内缓冲区的使用情况@                    |
| -v          | 显示索引节点，文件和其他内核表的状态                 |
| -n          | 显示网络运行状态@                                    |
| -q          | 显示运行队列的大小，它与系统当时的平均负载相同@      |
| -R          | 显示进程在采样时间内的活动情况                       |
| -y          | 显示终端设备在采样时间内的活动情况                   |
| -w          | 显示系统交换活动在采样时间内的状态                   |
| -o filename | 将命令结果以二进制格式存放在文件中，filename是文件名 |

#### 3.8.2 使用范例

（1）查看系统CPU的整体负载情况

```
[root@Mr_chen ~]# sar -u 2 3
Linux 2.6.32-431.el6.x86_64 (Mr_chen)   03/10/2018  _x86_64_    (1 CPU)

11:44:34 PM     CPU     %user     %nice   %system   %iowait    %steal     %idle
11:44:36 PM     all      0.00      0.00      1.00      0.00      0.00     99.00
11:44:38 PM     all      0.00      0.00      0.50      0.00      0.00     99.50
11:44:40 PM     all      0.00      0.00      0.00      0.00      0.00    100.00
Average:        all      0.00      0.00      0.50      0.00      0.00     99.50
```

> 以下是命令结果的详细说明
>
> - [x] %user:用户进程消耗的CPU时间百分比
> - [x] %nice:改变过优先级的进程占用的CPU时间百分比
> - [x] %system:系统（内核）进程消耗的CPU时间百分比
> - [x] %iowait:IO等待所占用的CPU时间百分比
> - [x] steal:虚拟机强制CPU等待的时间百分比
> - [x] idle:CPU处在空闲状态的时间百分比

（2）显示运行队列的大小

```
[root@localhost ~]# sar -q 2 3  #使用-q选项显示运行队列的大小
Linux 2.6.32-431.el6.x86_64 (localhost)     03/14/2018  _x86_64_    (1 CPU)

04:59:18 PM   runq-sz  plist-sz   ldavg-1   ldavg-5  ldavg-15
04:59:20 PM         0        69      0.00      0.00      0.00
04:59:22 PM         0        69      0.00      0.00      0.00
04:59:24 PM         0        70      0.00      0.00      0.00
Average:            0        69      0.00      0.00      0.00
```

> 以下是命令结果的详解说明
>
> - [x] runq-sz:运行队列的长度（等待运行的进程数）
> - [x] plist-sz:进程列表中进程（process）和线程（thread）的数量
> - [x] ldavg-1:最后一分钟的系统平均负载（system load average）
> - [x] ldavg-5:过去5分钟的系统平均负载
> - [x] ldavg-15:过去15分钟的系统平均负载

（3）显示系统内存的使用状况

```
[root@localhost ~]# sar -r 2 3  #使用-r选项显示系统内存在采样时间内的使用状况
Linux 2.6.32-431.el6.x86_64 (localhost)     03/14/2018  _x86_64_    (1 CPU)

05:03:44 PM kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit
05:03:46 PM    913012     91400      9.10     11136     23324     43344      1.43
05:03:48 PM    913012     91400      9.10     11136     23324     43344      1.43
05:03:50 PM    913012     91400      9.10     11136     23324     43344      1.43
Average:       913012     91400      9.10     11136     23324     43344      1.43
```

> 以下命令结果的详细说明
>
> - [x] kbmemfree:空闲物理内存量
> - [x] kbmemused:使用中的物理内存量
> - [x] %memused:物理内存量的使用率
> - [x] kbbuffers:内核中作为缓冲区使用的物理内存容量
> - [x] kbcached:内核中作为缓存使用的物理内存容量
> - [x] kbcommit:应用程序当前使用的内存大小
> - [x] %commit:应用程序当前使用的内存大小占总大小的使用百分比

（4）显示缓冲区的使用情况

```
[root@localhost ~]# sar -b 2 3  #使用-b选项显示缓冲区在采样时间内的使用情况
Linux 2.6.32-431.el6.x86_64 (localhost)     03/14/2018  _x86_64_    (1 CPU)

05:15:01 PM       tps      rtps      wtps   bread/s   bwrtn/s
05:15:03 PM      0.00      0.00      0.00      0.00      0.00
05:15:05 PM      0.00      0.00      0.00      0.00      0.00
05:15:07 PM      0.00      0.00      0.00      0.00      0.00
Average:         0.00      0.00      0.00      0.00      0.00
```

> 以下是命令的详细结果说明
>
> - [x] tps：每秒钟物理设备的I/O传输总量
> - [x] rtps:每秒钟从物理设备读入的数据总量
> - [x] wtps:每秒钟向物理设备写入的数据总量
> - [x] bread/s:每秒钟从物理设备读入的数据量，单位为块/s
> - [x] bwrtn/s:每秒钟向物理设备写入的数据量，单位为块/s

（5）显示网络的运行状态

```
我们先来看一下显示网络接口信息的命令
[root@localhost ~]# sar -n DEV 2 3  #使用-n DEV显示网络接口的信息
Linux 2.6.32-431.el6.x86_64 (localhost)     03/14/2018  _x86_64_    (1 CPU)

05:22:13 PM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s
05:22:15 PM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00
05:22:15 PM      eth0      0.00      0.00      0.00      0.00      0.00      0.00      0.00
05:22:15 PM      eth1      0.00      0.00      0.00      0.00      0.00      0.00      0.00

05:22:15 PM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s
05:22:17 PM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00
05:22:17 PM      eth0      0.50      0.50      0.03      0.24      0.00      0.00      0.00
05:22:17 PM      eth1      0.00      0.00      0.00      0.00      0.00      0.00      0.00

05:22:17 PM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s
05:22:19 PM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00
05:22:19 PM      eth0      0.50      0.50      0.03      0.24      0.00      0.00      0.00
05:22:19 PM      eth1      0.00      0.00      0.00      0.00      0.00      0.00      0.00

Average:        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s
Average:           lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00
Average:         eth0      0.33      0.33      0.02      0.16      0.00      0.00      0.00
Average:         eth1      0.00      0.00      0.00      0.00      0.00      0.00      0.00
```

> 以下是命令结果的详细说明
>
> - [x] IFACE:网络接口
> - [x] rxpck/s:每秒钟接收的数据包
> - [x] txpck/s:每秒钟发送的数据包
> - [x] rxkB/s:每秒钟接收的字节数
> - [x] txkB/s:每秒钟发送的字节数
> - [x] rxcmp/s:每秒钟接收的压缩数据包
> - [x] txcmp/s:每秒钟发送的压缩数据包
> - [x] rxmcst/s:每秒钟接收的多播数据包

```
下面的命令用来显示网络错误的统计数据
[root@localhost ~]# sar -n EDEV 2 3 #使用-n EDEV显示网络错误的统计数据
Linux 2.6.32-431.el6.x86_64 (localhost)     03/14/2018  _x86_64_    (1 CPU)

05:32:03 PM     IFACE   rxerr/s   txerr/s    coll/s  rxdrop/s  txdrop/s  txcarr/s  rxfram/s  rxfifo/s  txfifo/s
05:32:05 PM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
05:32:05 PM      eth0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
05:32:05 PM      eth1      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00

05:32:05 PM     IFACE   rxerr/s   txerr/s    coll/s  rxdrop/s  txdrop/s  txcarr/s  rxfram/s  rxfifo/s  txfifo/s
05:32:07 PM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
05:32:07 PM      eth0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
05:32:07 PM      eth1      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00

05:32:07 PM     IFACE   rxerr/s   txerr/s    coll/s  rxdrop/s  txdrop/s  txcarr/s  rxfram/s  rxfifo/s  txfifo/s
05:32:09 PM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
05:32:09 PM      eth0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
05:32:09 PM      eth1      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00

Average:        IFACE   rxerr/s   txerr/s    coll/s  rxdrop/s  txdrop/s  txcarr/s  rxfram/s  rxfifo/s  txfifo/s
Average:           lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
Average:         eth0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
Average:         eth1      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
```

> 以下是命令结果的详细说明
>
> - [x] IFACE:网络接口
> - [x] rxerr/s:每秒钟接收的坏数据包
> - [x] txerr/s:每秒钟发送的坏数据包
> - [x] coll/s:每秒的冲突数
> - [x] rxdrop/s:因为缓冲充满，每秒钟丢弃的已接收数据包数
> - [x] txdrop/s:因为缓冲充满，每秒钟丢弃的已发送数据包数
> - [x] txcarr/s:发送数据包时，每秒载波错误数
> - [x] rxfram/s:每秒接收数据包的帧对齐错误数
> - [x] rxfifo/s:接收的数据包每秒FIFO过速的错误数
> - [x] txfifo/s:发送的数据包每秒FIFO过速的错误数

```
下面的命令用于显示套接字信息
[root@Mr_chen ~]# sar -n SOCK 2 3   #使用-n SOCK显示套接字信息
Linux 2.6.32-431.el6.x86_64 (Mr_chen)   03/14/2018  _x86_64_    (1 CPU)

05:42:12 PM    totsck    tcpsck    udpsck    rawsck   ip-frag    tcp-tw
05:42:14 PM       281         2         0         0         0         0
05:42:16 PM       281         2         0         0         0         0
05:42:18 PM       281         2         0         0         0         0
Average:          281         2         0         0         0         0
```

> 以下是命令结果的详细说明
>
> - [x] totsck：使用的套接字总数量
> - [x] tcpsck：使用的TCP套接字数量
> - [x] udpsck：使用的UDP套接字数量
> - [x] rawsck：使用的raw套接字数量
> - [x] ip-frag：使用的IP段数量
> - [x] tcp-tw：处于TIME_WAIT状态的TCP套接字数量

（6）查看系统磁盘的读写性能

```
[root@Mr_chen ~]# sar -d 2 3    #使用-d选项显示系统所有硬盘设备在采样时间内的使用状况
Linux 2.6.32-431.el6.x86_64 (Mr_chen)   03/14/2018  _x86_64_    (1 CPU)

05:47:59 PM       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util
05:48:01 PM   dev11-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
05:48:01 PM    dev8-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
05:48:01 PM  dev253-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
05:48:01 PM  dev253-1      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00

05:48:01 PM       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util
05:48:03 PM   dev11-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
05:48:03 PM    dev8-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
05:48:03 PM  dev253-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
05:48:03 PM  dev253-1      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00

05:48:03 PM       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util
05:48:05 PM   dev11-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
05:48:05 PM    dev8-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
05:48:05 PM  dev253-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
05:48:05 PM  dev253-1      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00

Average:          DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util
Average:      dev11-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
Average:       dev8-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
Average:     dev253-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
Average:     dev253-1      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
```

> 以下是命令结果的详细说明
>
> - [x] DEV:表示磁盘的设备名称
> - [x] tps:表示该设备每秒的传输次数，“一次传输”的意思是“一次I/O请求”，多个逻辑请求可能会被合并为“一次I/O请求”，“一次传输”请求的大小是未知的。
> - [x] rd_sec/s:表示每秒从设备读取的扇区数
> - [x] wr_sec/s:表示每秒写入设备的扇区数目
> - [x] avgrq-sz:设备平均每次I/O操作的数据大小（扇区）
> - [x] avgqu-sz:平均I/O队列长度
> - [x] await:设备平均每次I/O操作的等待时间（毫秒）
> - [x] svctm:设备平均每次I/O操作的服务时间（毫秒）
> - [x] %util:每秒钟用于I/O操作的百分比

## 四，Linux核心内置管理命令

### 4.1 占位符“：”

（1）在Shell脚本中使用占位符的例子

```
if [ $i -eq 1 ] #条件表达式
    then
        ：  #在Shell脚本里若用到了if判断语句，那么判断成功后通常会执行某些操作，但有时会不                 知道执行什么操作或者不需要执行某些操作。但是又碍于if语句的固定语法格式，不                 得不写一个命令占位置，因为这一行如果没有内容就会语法报错，此时就会用到“：”                 这个占位符，不过请放心，这个命令不会对你的Shell脚本造成任何影响，其有点像                 其他编程语言的pass字段一样
else
    echo “hello world”
fi
```

### 4.2 ulimit修改系统资源使用限制

#### 4.2.1 命令详解

**功能说明：**

> ulimit命令用于查看系统资源的使用情况，同时也可以修改进程或用户等对系统资源分配的额度

**选项说明：**

| 参数选项 | 解释说明                     |
| -------- | ---------------------------- |
| -a       | 显示当前所有系统资源使用限制 |
| -n       | 显示或设置最多打开的文件数目 |

#### 4.2.2 使用范例

（1）显示当前所有系统资源使用限制

```
[root@Mr_chen ~]# ulimit -a 
core file size          (blocks, -c) 0  #core文件的最大值为100blocks
data seg size           (kbytes, -d) unlimited  #进程的数据段可以任意大
scheduling priority             (-e) 0          #调度优先级
file size               (blocks, -f) unlimited  #文件可以任意大
pending signals                 (-i) 7696       #最多有7696个待处理的信号
max locked memory       (kbytes, -l) 64         #一个任务锁住的物理内存的最大值为64KB
max memory size         (kbytes, -m) unlimited  #一个任务的常驻物理内存的最大值
open files                      (-n) 1024       #一个任务最多可以同时打开1024个文件
pipe size            (512 bytes, -p) 8          #管道的最大空间为4096（512*8）字节
POSIX message queues     (bytes, -q) 819200     #POSIX的消息队列的最大值为819200字节
real-time priority              (-r) 0          #real-time调度优先级
stack size              (kbytes, -s) 10240      #进程的栈的最大值为10240字节
cpu time               (seconds, -t) unlimited  #进程使用的CPU时间
max user processes              (-u) 7696       #当前用户同时打开的进程（包括线程）的最大个数为7696
virtual memory          (kbytes, -v) unlimited  #没有限制进程的最大地址空间
file locks                      (-x) unlimited  #所能锁住的文件的最大个数没有限制
```

（2）加大服务器打开文件描述符的数量

```
[root@Mr_chen ~]# ulimit -n
1024        #默认新系统的最大文件打开数（也叫文件描述符）为1024，这个值对于生产环境的服务器来说太小了，因此通常会在优化服务器环节把这个值调大
[root@Mr_chen ~]# ulimit -n 65535   #调整数量为65535，但是通过命令调整的只对当前窗口生效，因此需要修改配置文件
[root@Mr_chen ~]# ulimit -n
65535
[root@Mr_chen ~]# echo "* - nofile 65535" >> /etc/security/limits.conf  #修改配置文件永久生效，*表示针对任意用户生效
```

