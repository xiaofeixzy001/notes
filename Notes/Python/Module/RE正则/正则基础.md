[TOC]

# 概述

正则表达式，Regular Expression,缩写为regex,regexp,RE.

就是用一些具有特殊含义的符号组合到一起来描述字符或者字符串的方法,或者说正则就是用来描述一类事物的规则。

在Python中通过re模块实现。

正则表达式是文本处理极为重要的技术，用它可以对字符串按照某种规则进行检索、替换。

参考资料：https://www.w3cschool.cn/regex_rmjc/

在线调试工具：tool.oschina.net/regex/

# 分类

BRE：基本正则表达式，grep,sed,vi等软件支持，vim有扩展。

ERE：扩展正则表达式，egrep(grep -E), sed -r等。

PCRE：几乎所有高级语言都是PCRE的方言或变种。python从1.6开始使用SRE正则表达式引擎，可以认为是PCRE的子集，见模块RE。

# 基本语法

## 元字符

metacharacter

. 匹配除换行符外任意一个字符

[abc] 字符集合，只能表示一个字符位置，匹配所包含的任意一个字符

[^abc] 字符集合，只能表示一个字符位置，匹配除去集合内字符的任意一个字符

[a-z] 字符范围，集合，表示一个字符位置，匹配所包含的任意一个字符

[^a-z] 字符范围，集合，表示一个字符位置，匹配除去集合内字符的任意一个字符

\b 匹配单词的边界, 如\ba表示找到a开头的a字符

\B 不匹配单词的边界, 如a\B表示包含a但不以a结尾的a字符,\Ba表示匹配不以a开头但含有a的字符

\d [0-9]匹配1位数字

\D [^0-9]匹配1位非数字

\s 匹配1位空白字符,包括换行符、制表符、空格[\f,\r,\n,\t,\v]

\S 匹配1位非空白字符

\w 匹配[a-zA-Z0-9]包括中文的1个字符

\W 匹配\w之外的1个字符

## 转义

一段正则表达式，先交由python解释器来解释，然后再交由re模块执行解释，所以除了要注意正则表达式的元字符格式，也要注意python解释器对一些特殊符号的特殊意义.

凡是在正则表达式中有特殊意义的符号，如果想使用它的本意，请使用\转义，反斜杠自身，使用\\

\r、\n在python解释器中是回车、换行的意思，会被优先解释，然后在交由re模块解释

如果不想经过python解释器解释，直接原封不动的将字符串交给re模块，加一个r即可

## 重复

\* 表示前面的正则表达式会匹配0次或多次

\+ 表示前面的正则表达式匹配至少1次

? 表示前面的正则表达式重复0次或1次

{n} 重复固定的n次

{n,} 重复至少n次, e\w{1,} 等价于e\w+

{n,m} 重复n到m次, e\w{0,} 等价于e\w*

x|y 匹配x或y, e\w{0,1} 等价于e\w?

 

```
print(re.findall('compan(y|ies)', 'Too many companies have gone bankrupt, and the next one is my company'))
print(re.findall('compan(?:y|ies)', 'Too many companies have gone bankrupt, and the next one is my company'))
'''
运行结果：
['ies', 'y']
['companies', 'company']
'''
```

练习

1,匹配手机号码，字符串为"手机号码13851888188。"

\d{11}

\b1[3578][0-9]\d{8}

2,匹配座机号码,字符串为"号码025-83105736、0543-5467328。"

\d{3,4}-\d{7,8}

## 捕获/分组

(pattern) 使用小括号指定一个子表达式,也叫分组。捕获后会自动分配组号从1开始可以改变优先级。

\数字 匹配对应的分组,引用的是前面RE匹配到的结果

(?:pattern) 如果仅仅为了改变优先级而不需要捕获分组，则加?:

(?<name>exp)(?'name'exp) 分组捕获，但是可以通过name访问分组，也叫有名分组。

### 有名分组

Python中有名分组的语法格式：

(?P<name>pattern)

 

```
ret=re.search("a(?P<id>\d+)b","5weqa999bwre126")
'''
['a999b']
'''
```

## 断言

### 零宽断言

(?=exp) 零宽度正预测先行断言，断言exp一定在匹配的右边出现,也就是说断言后面一定跟个exp。

例如：

'wood took food book tool'  (w|f)(?=oo)  --> w,t,f,b,t

w或f的后面一定是oo

可以将?=oo理解成if条件,如果后面跟的是oo就匹配前面的条件(w|f), oo不会显示

(?<=exp) 零宽度正回顾后发断言，断言exp一定出现在匹配的左边出现，也就是说前面一定有个exp前缀.

例如：

'wood took food book tool'  (?<=oo)d --> d,d

d的前面一定是oo

### 负向零宽断言

(?!exp) 零宽度负预测先行断言，断言exp一定不会出现在右侧，也就是说断言后面一定不是exp

例如：

\d{3}(?!\d) 匹配3位数字，断言3位数字后面一定不能再有数字了

foo(?!d)  foo后面一定不能有d了

(?<!exp) 零宽度负回顾后发断言，断言exp一定不能出现在左侧，也就是说断言前面一定不能是exp

例如：(?<!f)ood  ood的前面一定不是f

断言不占分组号，断言如同条件，只是要求匹配必须满足断言的条件，不会显示

分组和捕获是同一个意思，使用正则表达式时，能用简单表达式就不要负责的表达式

## 注释

(?#comment) 注释

## 贪婪与非贪婪

默认是贪婪模式，也就是说尽量多匹配更长的字符串。

非贪婪模式，在重复的符号后面加上一个问号?，就尽量的少匹配了。

*? 匹配任意次，但尽可能少重复

+? 匹配至少1次，但尽可能少重复

?? 匹配0次货1次，但尽可能少重复

{n,}? 匹配至少n次，但尽可能少重复

{n,m}? 匹配至少n次，至多m次，但尽可能少重复

.*:任意长度的任意字符，贪婪匹配

.*?:非贪婪匹配,?表示将.*转换为非贪婪模式

 

```
print(re.findall('a.*c','ac abc aec a1c'))  #开头是a，最后是c
'''
运行结果：
['ac abc aec a1c'] #一个值
'''

print(re.findall('a.*?c','ac abc aec a1c'))
print(re.findall('a.*?c','ac abc a111111111c a\nc a1c',re.S))
'''
运行结果：
['ac', 'abc', 'aec', 'a1c'] #列表多个值
['ac', 'abc', 'a111111111c', 'a\nc', 'a1c'] #列表多个值
'''
```

## 引擎选项

IgnoreCase 匹配时忽略大小写，python语法：re.I & re.IGNORECASE

Singleline 单行模式.可匹配所有字符,包括\n，python语法：re.S & re.DOTALL

Multiline 多行模式,^行首,$行尾, python语法：re.M & re.MULTILINE

IgnorePatternWhitespace 忽略表达式中的空白字符，如果要是用空白字符用转移符,井号#可以用来做注释, python语法: re.X & re.VERBOSE

单行模式

. 可以匹配所有字符,包括换行符.

^ 表示整个字符串的开头

$ 整个字符串的结尾

多行模式

. 可以匹配除了换行符之外的字符

^ 表示行首，整个字符串的开始，开始是指的\n后紧接着下一个字符

$ 行尾，整个字符串的结尾,结束是\n前的字符

可以认为,单行模式就如同看穿了换行符，所有文本就是一个长长的只有一行的字符串，所有^就是这一行字符串的行首，$就是这一行的行尾。

多行模式，无法穿透换行符，^和$还是行首行尾的意思，只不过限于每一行。

注意：字符串中看不见的换行符,\r\n会影响e$的测试,e$只能匹配e\n

例如：

字符串：

very very happy

harry key

y$单行匹配最后的key的y, 多行匹配happy的y和key的y

# 练习

匹配一个0-999之间的任意数字

1

12

995

9999

102

02

003

4d

 

```
\d  # 1位
[1-9]?\d  # 1-2位
^([1-9]\d\d?|\d)  # 1-3位
^([1-9]\d\d?|\d)$  # 1-3位数的行
^([1-9]\d\d?|\d)\r?$  # 1-3位数且以回车符结尾
^([1-9]\d\d?|\d)(?!\d)  # 数字开头1-3位数且之后不能是数字
```

匹配合法的IP地址

192.168.1.150

0.0.0.0

255.255.255.255

17.16.52.100

172.16.0.100

400.400.999.888

001.022.003.000

257.257.255.256

 

```
(?:(25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)

import socket
nw = socket.inet_aton('192.168.05.001')
print(nw, socket.inet_ntoa(nw))
```

对于IP地址验证的问题

可以把数据提出来后，交给ip地址解析库处理，如果解析异常就说明有问题，正则的验证只是一个初步的筛选，把明显的错误过滤掉

可以使用复杂的正则表达式验证地址的正确性

前导0是可以的

选出含有ftp的链接且文件类型是gz或者xz的文件名

![img](%E6%AD%A3%E5%88%99%E5%9F%BA%E7%A1%80.assets/64499a44-94ee-4a80-8366-8f35eae91b80.png)

 

```
.*ftp.*\.(?:gz|xz)
ftp.*/(.*(?:gz|xz))
.*ftp.*/([^/]+\.(?:gz|xz))  # 捕获文件名分组
(?<=.*ftp.*/)([^/]*\.(?:gz|xz))  # 断言文件名前一定还有ftp
```